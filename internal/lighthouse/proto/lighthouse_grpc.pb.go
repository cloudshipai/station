// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: internal/proto/lighthouse.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	LighthouseService_RegisterStation_FullMethodName       = "/lighthouse.v1.LighthouseService/RegisterStation"
	LighthouseService_Heartbeat_FullMethodName             = "/lighthouse.v1.LighthouseService/Heartbeat"
	LighthouseService_SendRun_FullMethodName               = "/lighthouse.v1.LighthouseService/SendRun"
	LighthouseService_SendRunStream_FullMethodName         = "/lighthouse.v1.LighthouseService/SendRunStream"
	LighthouseService_SendEphemeralSnapshot_FullMethodName = "/lighthouse.v1.LighthouseService/SendEphemeralSnapshot"
	LighthouseService_Connect_FullMethodName               = "/lighthouse.v1.LighthouseService/Connect"
	LighthouseService_SyncConfiguration_FullMethodName     = "/lighthouse.v1.LighthouseService/SyncConfiguration"
	LighthouseService_ManagementChannel_FullMethodName     = "/lighthouse.v1.LighthouseService/ManagementChannel"
	LighthouseService_GetAgentDetails_FullMethodName       = "/lighthouse.v1.LighthouseService/GetAgentDetails"
	LighthouseService_UpdateAgentPrompt_FullMethodName     = "/lighthouse.v1.LighthouseService/UpdateAgentPrompt"
	LighthouseService_SendSystemHealth_FullMethodName      = "/lighthouse.v1.LighthouseService/SendSystemHealth"
	LighthouseService_IngestData_FullMethodName            = "/lighthouse.v1.LighthouseService/IngestData"
	LighthouseService_ListTools_FullMethodName             = "/lighthouse.v1.LighthouseService/ListTools"
	LighthouseService_CallTool_FullMethodName              = "/lighthouse.v1.LighthouseService/CallTool"
	LighthouseService_ListAgents_FullMethodName            = "/lighthouse.v1.LighthouseService/ListAgents"
	LighthouseService_ExecuteAgent_FullMethodName          = "/lighthouse.v1.LighthouseService/ExecuteAgent"
	LighthouseService_ListStations_FullMethodName          = "/lighthouse.v1.LighthouseService/ListStations"
)

// LighthouseServiceClient is the client API for LighthouseService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Lighthouse service for Station-CloudShip integration
// Handles all three deployment modes: stdio, serve, cli
type LighthouseServiceClient interface {
	// Registration & Connection Management
	RegisterStation(ctx context.Context, in *RegisterStationRequest, opts ...grpc.CallOption) (*RegisterStationResponse, error)
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
	// Run Data Collection (All Modes)
	SendRun(ctx context.Context, in *SendRunRequest, opts ...grpc.CallOption) (*SendRunResponse, error)
	SendRunStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SendRunRequest, SendRunResponse], error)
	// CLI Mode Versioned Snapshots
	SendEphemeralSnapshot(ctx context.Context, in *EphemeralSnapshotRequest, opts ...grpc.CallOption) (*EphemeralSnapshotResponse, error)
	// Configuration Management (Server Mode Only)
	Connect(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ConnectRequest, CloudShipCommand], error)
	SyncConfiguration(ctx context.Context, in *SyncConfigRequest, opts ...grpc.CallOption) (*SyncConfigResponse, error)
	// Management Channel (Bidirectional for firewall traversal)
	ManagementChannel(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ManagementMessage, ManagementMessage], error)
	// Agent Configuration Management (Unary APIs for external clients like Django)
	GetAgentDetails(ctx context.Context, in *GetAgentDetailsRequest, opts ...grpc.CallOption) (*GetAgentDetailsResponse, error)
	UpdateAgentPrompt(ctx context.Context, in *UpdateAgentPromptRequest, opts ...grpc.CallOption) (*UpdateAgentPromptResponse, error)
	// System Health Monitoring (Server Mode Primarily)
	SendSystemHealth(ctx context.Context, in *SystemHealthRequest, opts ...grpc.CallOption) (*SystemHealthResponse, error)
	// Flexible Data Ingestion Pipeline (Phase 3)
	IngestData(ctx context.Context, in *IngestDataRequest, opts ...grpc.CallOption) (*IngestDataResponse, error)
	// Legacy MCP Proxy (Deprecated - use ManagementChannel)
	ListTools(ctx context.Context, in *ListToolsRequest, opts ...grpc.CallOption) (*ListToolsResponse, error)
	CallTool(ctx context.Context, in *CallToolRequest, opts ...grpc.CallOption) (*CallToolResponse, error)
	ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error)
	ExecuteAgent(ctx context.Context, in *ExecuteAgentRequest, opts ...grpc.CallOption) (*ExecuteAgentResponse, error)
	// Station Discovery (Multi-station support)
	ListStations(ctx context.Context, in *ListStationsRequest, opts ...grpc.CallOption) (*ListStationsResponse, error)
}

type lighthouseServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLighthouseServiceClient(cc grpc.ClientConnInterface) LighthouseServiceClient {
	return &lighthouseServiceClient{cc}
}

func (c *lighthouseServiceClient) RegisterStation(ctx context.Context, in *RegisterStationRequest, opts ...grpc.CallOption) (*RegisterStationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterStationResponse)
	err := c.cc.Invoke(ctx, LighthouseService_RegisterStation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, LighthouseService_Heartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) SendRun(ctx context.Context, in *SendRunRequest, opts ...grpc.CallOption) (*SendRunResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendRunResponse)
	err := c.cc.Invoke(ctx, LighthouseService_SendRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) SendRunStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SendRunRequest, SendRunResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LighthouseService_ServiceDesc.Streams[0], LighthouseService_SendRunStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SendRunRequest, SendRunResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LighthouseService_SendRunStreamClient = grpc.BidiStreamingClient[SendRunRequest, SendRunResponse]

func (c *lighthouseServiceClient) SendEphemeralSnapshot(ctx context.Context, in *EphemeralSnapshotRequest, opts ...grpc.CallOption) (*EphemeralSnapshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EphemeralSnapshotResponse)
	err := c.cc.Invoke(ctx, LighthouseService_SendEphemeralSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) Connect(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ConnectRequest, CloudShipCommand], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LighthouseService_ServiceDesc.Streams[1], LighthouseService_Connect_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ConnectRequest, CloudShipCommand]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LighthouseService_ConnectClient = grpc.BidiStreamingClient[ConnectRequest, CloudShipCommand]

func (c *lighthouseServiceClient) SyncConfiguration(ctx context.Context, in *SyncConfigRequest, opts ...grpc.CallOption) (*SyncConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncConfigResponse)
	err := c.cc.Invoke(ctx, LighthouseService_SyncConfiguration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) ManagementChannel(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ManagementMessage, ManagementMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LighthouseService_ServiceDesc.Streams[2], LighthouseService_ManagementChannel_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ManagementMessage, ManagementMessage]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LighthouseService_ManagementChannelClient = grpc.BidiStreamingClient[ManagementMessage, ManagementMessage]

func (c *lighthouseServiceClient) GetAgentDetails(ctx context.Context, in *GetAgentDetailsRequest, opts ...grpc.CallOption) (*GetAgentDetailsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAgentDetailsResponse)
	err := c.cc.Invoke(ctx, LighthouseService_GetAgentDetails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) UpdateAgentPrompt(ctx context.Context, in *UpdateAgentPromptRequest, opts ...grpc.CallOption) (*UpdateAgentPromptResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateAgentPromptResponse)
	err := c.cc.Invoke(ctx, LighthouseService_UpdateAgentPrompt_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) SendSystemHealth(ctx context.Context, in *SystemHealthRequest, opts ...grpc.CallOption) (*SystemHealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SystemHealthResponse)
	err := c.cc.Invoke(ctx, LighthouseService_SendSystemHealth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) IngestData(ctx context.Context, in *IngestDataRequest, opts ...grpc.CallOption) (*IngestDataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IngestDataResponse)
	err := c.cc.Invoke(ctx, LighthouseService_IngestData_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) ListTools(ctx context.Context, in *ListToolsRequest, opts ...grpc.CallOption) (*ListToolsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListToolsResponse)
	err := c.cc.Invoke(ctx, LighthouseService_ListTools_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) CallTool(ctx context.Context, in *CallToolRequest, opts ...grpc.CallOption) (*CallToolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CallToolResponse)
	err := c.cc.Invoke(ctx, LighthouseService_CallTool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAgentsResponse)
	err := c.cc.Invoke(ctx, LighthouseService_ListAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) ExecuteAgent(ctx context.Context, in *ExecuteAgentRequest, opts ...grpc.CallOption) (*ExecuteAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteAgentResponse)
	err := c.cc.Invoke(ctx, LighthouseService_ExecuteAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) ListStations(ctx context.Context, in *ListStationsRequest, opts ...grpc.CallOption) (*ListStationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListStationsResponse)
	err := c.cc.Invoke(ctx, LighthouseService_ListStations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LighthouseServiceServer is the server API for LighthouseService service.
// All implementations must embed UnimplementedLighthouseServiceServer
// for forward compatibility.
//
// Lighthouse service for Station-CloudShip integration
// Handles all three deployment modes: stdio, serve, cli
type LighthouseServiceServer interface {
	// Registration & Connection Management
	RegisterStation(context.Context, *RegisterStationRequest) (*RegisterStationResponse, error)
	Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	// Run Data Collection (All Modes)
	SendRun(context.Context, *SendRunRequest) (*SendRunResponse, error)
	SendRunStream(grpc.BidiStreamingServer[SendRunRequest, SendRunResponse]) error
	// CLI Mode Versioned Snapshots
	SendEphemeralSnapshot(context.Context, *EphemeralSnapshotRequest) (*EphemeralSnapshotResponse, error)
	// Configuration Management (Server Mode Only)
	Connect(grpc.BidiStreamingServer[ConnectRequest, CloudShipCommand]) error
	SyncConfiguration(context.Context, *SyncConfigRequest) (*SyncConfigResponse, error)
	// Management Channel (Bidirectional for firewall traversal)
	ManagementChannel(grpc.BidiStreamingServer[ManagementMessage, ManagementMessage]) error
	// Agent Configuration Management (Unary APIs for external clients like Django)
	GetAgentDetails(context.Context, *GetAgentDetailsRequest) (*GetAgentDetailsResponse, error)
	UpdateAgentPrompt(context.Context, *UpdateAgentPromptRequest) (*UpdateAgentPromptResponse, error)
	// System Health Monitoring (Server Mode Primarily)
	SendSystemHealth(context.Context, *SystemHealthRequest) (*SystemHealthResponse, error)
	// Flexible Data Ingestion Pipeline (Phase 3)
	IngestData(context.Context, *IngestDataRequest) (*IngestDataResponse, error)
	// Legacy MCP Proxy (Deprecated - use ManagementChannel)
	ListTools(context.Context, *ListToolsRequest) (*ListToolsResponse, error)
	CallTool(context.Context, *CallToolRequest) (*CallToolResponse, error)
	ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error)
	ExecuteAgent(context.Context, *ExecuteAgentRequest) (*ExecuteAgentResponse, error)
	// Station Discovery (Multi-station support)
	ListStations(context.Context, *ListStationsRequest) (*ListStationsResponse, error)
	mustEmbedUnimplementedLighthouseServiceServer()
}

// UnimplementedLighthouseServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLighthouseServiceServer struct{}

func (UnimplementedLighthouseServiceServer) RegisterStation(context.Context, *RegisterStationRequest) (*RegisterStationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterStation not implemented")
}
func (UnimplementedLighthouseServiceServer) Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedLighthouseServiceServer) SendRun(context.Context, *SendRunRequest) (*SendRunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendRun not implemented")
}
func (UnimplementedLighthouseServiceServer) SendRunStream(grpc.BidiStreamingServer[SendRunRequest, SendRunResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SendRunStream not implemented")
}
func (UnimplementedLighthouseServiceServer) SendEphemeralSnapshot(context.Context, *EphemeralSnapshotRequest) (*EphemeralSnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendEphemeralSnapshot not implemented")
}
func (UnimplementedLighthouseServiceServer) Connect(grpc.BidiStreamingServer[ConnectRequest, CloudShipCommand]) error {
	return status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedLighthouseServiceServer) SyncConfiguration(context.Context, *SyncConfigRequest) (*SyncConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncConfiguration not implemented")
}
func (UnimplementedLighthouseServiceServer) ManagementChannel(grpc.BidiStreamingServer[ManagementMessage, ManagementMessage]) error {
	return status.Errorf(codes.Unimplemented, "method ManagementChannel not implemented")
}
func (UnimplementedLighthouseServiceServer) GetAgentDetails(context.Context, *GetAgentDetailsRequest) (*GetAgentDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgentDetails not implemented")
}
func (UnimplementedLighthouseServiceServer) UpdateAgentPrompt(context.Context, *UpdateAgentPromptRequest) (*UpdateAgentPromptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAgentPrompt not implemented")
}
func (UnimplementedLighthouseServiceServer) SendSystemHealth(context.Context, *SystemHealthRequest) (*SystemHealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendSystemHealth not implemented")
}
func (UnimplementedLighthouseServiceServer) IngestData(context.Context, *IngestDataRequest) (*IngestDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IngestData not implemented")
}
func (UnimplementedLighthouseServiceServer) ListTools(context.Context, *ListToolsRequest) (*ListToolsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTools not implemented")
}
func (UnimplementedLighthouseServiceServer) CallTool(context.Context, *CallToolRequest) (*CallToolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallTool not implemented")
}
func (UnimplementedLighthouseServiceServer) ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAgents not implemented")
}
func (UnimplementedLighthouseServiceServer) ExecuteAgent(context.Context, *ExecuteAgentRequest) (*ExecuteAgentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteAgent not implemented")
}
func (UnimplementedLighthouseServiceServer) ListStations(context.Context, *ListStationsRequest) (*ListStationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStations not implemented")
}
func (UnimplementedLighthouseServiceServer) mustEmbedUnimplementedLighthouseServiceServer() {}
func (UnimplementedLighthouseServiceServer) testEmbeddedByValue()                           {}

// UnsafeLighthouseServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LighthouseServiceServer will
// result in compilation errors.
type UnsafeLighthouseServiceServer interface {
	mustEmbedUnimplementedLighthouseServiceServer()
}

func RegisterLighthouseServiceServer(s grpc.ServiceRegistrar, srv LighthouseServiceServer) {
	// If the following call pancis, it indicates UnimplementedLighthouseServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LighthouseService_ServiceDesc, srv)
}

func _LighthouseService_RegisterStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterStationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).RegisterStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_RegisterStation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).RegisterStation(ctx, req.(*RegisterStationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_SendRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).SendRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_SendRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).SendRun(ctx, req.(*SendRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_SendRunStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LighthouseServiceServer).SendRunStream(&grpc.GenericServerStream[SendRunRequest, SendRunResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LighthouseService_SendRunStreamServer = grpc.BidiStreamingServer[SendRunRequest, SendRunResponse]

func _LighthouseService_SendEphemeralSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EphemeralSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).SendEphemeralSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_SendEphemeralSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).SendEphemeralSnapshot(ctx, req.(*EphemeralSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LighthouseServiceServer).Connect(&grpc.GenericServerStream[ConnectRequest, CloudShipCommand]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LighthouseService_ConnectServer = grpc.BidiStreamingServer[ConnectRequest, CloudShipCommand]

func _LighthouseService_SyncConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).SyncConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_SyncConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).SyncConfiguration(ctx, req.(*SyncConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_ManagementChannel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LighthouseServiceServer).ManagementChannel(&grpc.GenericServerStream[ManagementMessage, ManagementMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LighthouseService_ManagementChannelServer = grpc.BidiStreamingServer[ManagementMessage, ManagementMessage]

func _LighthouseService_GetAgentDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).GetAgentDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_GetAgentDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).GetAgentDetails(ctx, req.(*GetAgentDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_UpdateAgentPrompt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAgentPromptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).UpdateAgentPrompt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_UpdateAgentPrompt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).UpdateAgentPrompt(ctx, req.(*UpdateAgentPromptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_SendSystemHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SystemHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).SendSystemHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_SendSystemHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).SendSystemHealth(ctx, req.(*SystemHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_IngestData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).IngestData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_IngestData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).IngestData(ctx, req.(*IngestDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_ListTools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListToolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).ListTools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_ListTools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).ListTools(ctx, req.(*ListToolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_CallTool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallToolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).CallTool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_CallTool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).CallTool(ctx, req.(*CallToolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_ListAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAgentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).ListAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_ListAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).ListAgents(ctx, req.(*ListAgentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_ExecuteAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).ExecuteAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_ExecuteAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).ExecuteAgent(ctx, req.(*ExecuteAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_ListStations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).ListStations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_ListStations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).ListStations(ctx, req.(*ListStationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LighthouseService_ServiceDesc is the grpc.ServiceDesc for LighthouseService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LighthouseService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lighthouse.v1.LighthouseService",
	HandlerType: (*LighthouseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterStation",
			Handler:    _LighthouseService_RegisterStation_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _LighthouseService_Heartbeat_Handler,
		},
		{
			MethodName: "SendRun",
			Handler:    _LighthouseService_SendRun_Handler,
		},
		{
			MethodName: "SendEphemeralSnapshot",
			Handler:    _LighthouseService_SendEphemeralSnapshot_Handler,
		},
		{
			MethodName: "SyncConfiguration",
			Handler:    _LighthouseService_SyncConfiguration_Handler,
		},
		{
			MethodName: "GetAgentDetails",
			Handler:    _LighthouseService_GetAgentDetails_Handler,
		},
		{
			MethodName: "UpdateAgentPrompt",
			Handler:    _LighthouseService_UpdateAgentPrompt_Handler,
		},
		{
			MethodName: "SendSystemHealth",
			Handler:    _LighthouseService_SendSystemHealth_Handler,
		},
		{
			MethodName: "IngestData",
			Handler:    _LighthouseService_IngestData_Handler,
		},
		{
			MethodName: "ListTools",
			Handler:    _LighthouseService_ListTools_Handler,
		},
		{
			MethodName: "CallTool",
			Handler:    _LighthouseService_CallTool_Handler,
		},
		{
			MethodName: "ListAgents",
			Handler:    _LighthouseService_ListAgents_Handler,
		},
		{
			MethodName: "ExecuteAgent",
			Handler:    _LighthouseService_ExecuteAgent_Handler,
		},
		{
			MethodName: "ListStations",
			Handler:    _LighthouseService_ListStations_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendRunStream",
			Handler:       _LighthouseService_SendRunStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Connect",
			Handler:       _LighthouseService_Connect_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ManagementChannel",
			Handler:       _LighthouseService_ManagementChannel_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "internal/proto/lighthouse.proto",
}

const (
	DebugService_GetActiveStations_FullMethodName           = "/lighthouse.v1.DebugService/GetActiveStations"
	DebugService_GetActiveManagementChannels_FullMethodName = "/lighthouse.v1.DebugService/GetActiveManagementChannels"
	DebugService_TestStationConnection_FullMethodName       = "/lighthouse.v1.DebugService/TestStationConnection"
)

// DebugServiceClient is the client API for DebugService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Debug service for lighthouse introspection and troubleshooting
type DebugServiceClient interface {
	// Get all active stations that lighthouse knows about
	GetActiveStations(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (*DebugResponse, error)
	// Get all active management channels
	GetActiveManagementChannels(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (*DebugResponse, error)
	// Test if a specific station is reachable
	TestStationConnection(ctx context.Context, in *TestStationRequest, opts ...grpc.CallOption) (*DebugResponse, error)
}

type debugServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDebugServiceClient(cc grpc.ClientConnInterface) DebugServiceClient {
	return &debugServiceClient{cc}
}

func (c *debugServiceClient) GetActiveStations(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (*DebugResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DebugResponse)
	err := c.cc.Invoke(ctx, DebugService_GetActiveStations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugServiceClient) GetActiveManagementChannels(ctx context.Context, in *DebugRequest, opts ...grpc.CallOption) (*DebugResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DebugResponse)
	err := c.cc.Invoke(ctx, DebugService_GetActiveManagementChannels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debugServiceClient) TestStationConnection(ctx context.Context, in *TestStationRequest, opts ...grpc.CallOption) (*DebugResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DebugResponse)
	err := c.cc.Invoke(ctx, DebugService_TestStationConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DebugServiceServer is the server API for DebugService service.
// All implementations must embed UnimplementedDebugServiceServer
// for forward compatibility.
//
// Debug service for lighthouse introspection and troubleshooting
type DebugServiceServer interface {
	// Get all active stations that lighthouse knows about
	GetActiveStations(context.Context, *DebugRequest) (*DebugResponse, error)
	// Get all active management channels
	GetActiveManagementChannels(context.Context, *DebugRequest) (*DebugResponse, error)
	// Test if a specific station is reachable
	TestStationConnection(context.Context, *TestStationRequest) (*DebugResponse, error)
	mustEmbedUnimplementedDebugServiceServer()
}

// UnimplementedDebugServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDebugServiceServer struct{}

func (UnimplementedDebugServiceServer) GetActiveStations(context.Context, *DebugRequest) (*DebugResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveStations not implemented")
}
func (UnimplementedDebugServiceServer) GetActiveManagementChannels(context.Context, *DebugRequest) (*DebugResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActiveManagementChannels not implemented")
}
func (UnimplementedDebugServiceServer) TestStationConnection(context.Context, *TestStationRequest) (*DebugResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestStationConnection not implemented")
}
func (UnimplementedDebugServiceServer) mustEmbedUnimplementedDebugServiceServer() {}
func (UnimplementedDebugServiceServer) testEmbeddedByValue()                      {}

// UnsafeDebugServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DebugServiceServer will
// result in compilation errors.
type UnsafeDebugServiceServer interface {
	mustEmbedUnimplementedDebugServiceServer()
}

func RegisterDebugServiceServer(s grpc.ServiceRegistrar, srv DebugServiceServer) {
	// If the following call pancis, it indicates UnimplementedDebugServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DebugService_ServiceDesc, srv)
}

func _DebugService_GetActiveStations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DebugRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServiceServer).GetActiveStations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DebugService_GetActiveStations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServiceServer).GetActiveStations(ctx, req.(*DebugRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugService_GetActiveManagementChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DebugRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServiceServer).GetActiveManagementChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DebugService_GetActiveManagementChannels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServiceServer).GetActiveManagementChannels(ctx, req.(*DebugRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebugService_TestStationConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestStationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebugServiceServer).TestStationConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DebugService_TestStationConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebugServiceServer).TestStationConnection(ctx, req.(*TestStationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DebugService_ServiceDesc is the grpc.ServiceDesc for DebugService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DebugService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lighthouse.v1.DebugService",
	HandlerType: (*DebugServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetActiveStations",
			Handler:    _DebugService_GetActiveStations_Handler,
		},
		{
			MethodName: "GetActiveManagementChannels",
			Handler:    _DebugService_GetActiveManagementChannels_Handler,
		},
		{
			MethodName: "TestStationConnection",
			Handler:    _DebugService_TestStationConnection_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/proto/lighthouse.proto",
}
