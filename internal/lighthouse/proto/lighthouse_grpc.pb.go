// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: internal/lighthouse/proto/lighthouse.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	LighthouseService_RegisterStation_FullMethodName       = "/lighthouse.v1.LighthouseService/RegisterStation"
	LighthouseService_Heartbeat_FullMethodName             = "/lighthouse.v1.LighthouseService/Heartbeat"
	LighthouseService_SendRun_FullMethodName               = "/lighthouse.v1.LighthouseService/SendRun"
	LighthouseService_SendRunStream_FullMethodName         = "/lighthouse.v1.LighthouseService/SendRunStream"
	LighthouseService_SendEphemeralSnapshot_FullMethodName = "/lighthouse.v1.LighthouseService/SendEphemeralSnapshot"
	LighthouseService_Connect_FullMethodName               = "/lighthouse.v1.LighthouseService/Connect"
	LighthouseService_SyncConfiguration_FullMethodName     = "/lighthouse.v1.LighthouseService/SyncConfiguration"
	LighthouseService_ManagementChannel_FullMethodName     = "/lighthouse.v1.LighthouseService/ManagementChannel"
	LighthouseService_SendSystemHealth_FullMethodName      = "/lighthouse.v1.LighthouseService/SendSystemHealth"
	LighthouseService_ListTools_FullMethodName             = "/lighthouse.v1.LighthouseService/ListTools"
	LighthouseService_CallTool_FullMethodName              = "/lighthouse.v1.LighthouseService/CallTool"
	LighthouseService_ListAgents_FullMethodName            = "/lighthouse.v1.LighthouseService/ListAgents"
	LighthouseService_ExecuteAgent_FullMethodName          = "/lighthouse.v1.LighthouseService/ExecuteAgent"
)

// LighthouseServiceClient is the client API for LighthouseService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Lighthouse service for Station-CloudShip integration
// Handles all three deployment modes: stdio, serve, cli
type LighthouseServiceClient interface {
	// Registration & Connection Management
	RegisterStation(ctx context.Context, in *RegisterStationRequest, opts ...grpc.CallOption) (*RegisterStationResponse, error)
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
	// Run Data Collection (All Modes)
	SendRun(ctx context.Context, in *SendRunRequest, opts ...grpc.CallOption) (*SendRunResponse, error)
	SendRunStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SendRunRequest, SendRunResponse], error)
	// CLI Mode Versioned Snapshots
	SendEphemeralSnapshot(ctx context.Context, in *EphemeralSnapshotRequest, opts ...grpc.CallOption) (*EphemeralSnapshotResponse, error)
	// Configuration Management (Server Mode Only)
	Connect(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ConnectRequest, CloudShipCommand], error)
	SyncConfiguration(ctx context.Context, in *SyncConfigRequest, opts ...grpc.CallOption) (*SyncConfigResponse, error)
	// Management Channel (Bidirectional for firewall traversal)
	ManagementChannel(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ManagementMessage, ManagementMessage], error)
	// System Health Monitoring (Server Mode Primarily)
	SendSystemHealth(ctx context.Context, in *SystemHealthRequest, opts ...grpc.CallOption) (*SystemHealthResponse, error)
	// Legacy MCP Proxy (Deprecated - use ManagementChannel)
	ListTools(ctx context.Context, in *ListToolsRequest, opts ...grpc.CallOption) (*ListToolsResponse, error)
	CallTool(ctx context.Context, in *CallToolRequest, opts ...grpc.CallOption) (*CallToolResponse, error)
	ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error)
	ExecuteAgent(ctx context.Context, in *ExecuteAgentRequest, opts ...grpc.CallOption) (*ExecuteAgentResponse, error)
}

type lighthouseServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLighthouseServiceClient(cc grpc.ClientConnInterface) LighthouseServiceClient {
	return &lighthouseServiceClient{cc}
}

func (c *lighthouseServiceClient) RegisterStation(ctx context.Context, in *RegisterStationRequest, opts ...grpc.CallOption) (*RegisterStationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterStationResponse)
	err := c.cc.Invoke(ctx, LighthouseService_RegisterStation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, LighthouseService_Heartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) SendRun(ctx context.Context, in *SendRunRequest, opts ...grpc.CallOption) (*SendRunResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendRunResponse)
	err := c.cc.Invoke(ctx, LighthouseService_SendRun_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) SendRunStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SendRunRequest, SendRunResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LighthouseService_ServiceDesc.Streams[0], LighthouseService_SendRunStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SendRunRequest, SendRunResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LighthouseService_SendRunStreamClient = grpc.BidiStreamingClient[SendRunRequest, SendRunResponse]

func (c *lighthouseServiceClient) SendEphemeralSnapshot(ctx context.Context, in *EphemeralSnapshotRequest, opts ...grpc.CallOption) (*EphemeralSnapshotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EphemeralSnapshotResponse)
	err := c.cc.Invoke(ctx, LighthouseService_SendEphemeralSnapshot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) Connect(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ConnectRequest, CloudShipCommand], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LighthouseService_ServiceDesc.Streams[1], LighthouseService_Connect_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ConnectRequest, CloudShipCommand]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LighthouseService_ConnectClient = grpc.BidiStreamingClient[ConnectRequest, CloudShipCommand]

func (c *lighthouseServiceClient) SyncConfiguration(ctx context.Context, in *SyncConfigRequest, opts ...grpc.CallOption) (*SyncConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncConfigResponse)
	err := c.cc.Invoke(ctx, LighthouseService_SyncConfiguration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) ManagementChannel(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ManagementMessage, ManagementMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LighthouseService_ServiceDesc.Streams[2], LighthouseService_ManagementChannel_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ManagementMessage, ManagementMessage]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LighthouseService_ManagementChannelClient = grpc.BidiStreamingClient[ManagementMessage, ManagementMessage]

func (c *lighthouseServiceClient) SendSystemHealth(ctx context.Context, in *SystemHealthRequest, opts ...grpc.CallOption) (*SystemHealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SystemHealthResponse)
	err := c.cc.Invoke(ctx, LighthouseService_SendSystemHealth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) ListTools(ctx context.Context, in *ListToolsRequest, opts ...grpc.CallOption) (*ListToolsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListToolsResponse)
	err := c.cc.Invoke(ctx, LighthouseService_ListTools_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) CallTool(ctx context.Context, in *CallToolRequest, opts ...grpc.CallOption) (*CallToolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CallToolResponse)
	err := c.cc.Invoke(ctx, LighthouseService_CallTool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAgentsResponse)
	err := c.cc.Invoke(ctx, LighthouseService_ListAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lighthouseServiceClient) ExecuteAgent(ctx context.Context, in *ExecuteAgentRequest, opts ...grpc.CallOption) (*ExecuteAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteAgentResponse)
	err := c.cc.Invoke(ctx, LighthouseService_ExecuteAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LighthouseServiceServer is the server API for LighthouseService service.
// All implementations must embed UnimplementedLighthouseServiceServer
// for forward compatibility.
//
// Lighthouse service for Station-CloudShip integration
// Handles all three deployment modes: stdio, serve, cli
type LighthouseServiceServer interface {
	// Registration & Connection Management
	RegisterStation(context.Context, *RegisterStationRequest) (*RegisterStationResponse, error)
	Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	// Run Data Collection (All Modes)
	SendRun(context.Context, *SendRunRequest) (*SendRunResponse, error)
	SendRunStream(grpc.BidiStreamingServer[SendRunRequest, SendRunResponse]) error
	// CLI Mode Versioned Snapshots
	SendEphemeralSnapshot(context.Context, *EphemeralSnapshotRequest) (*EphemeralSnapshotResponse, error)
	// Configuration Management (Server Mode Only)
	Connect(grpc.BidiStreamingServer[ConnectRequest, CloudShipCommand]) error
	SyncConfiguration(context.Context, *SyncConfigRequest) (*SyncConfigResponse, error)
	// Management Channel (Bidirectional for firewall traversal)
	ManagementChannel(grpc.BidiStreamingServer[ManagementMessage, ManagementMessage]) error
	// System Health Monitoring (Server Mode Primarily)
	SendSystemHealth(context.Context, *SystemHealthRequest) (*SystemHealthResponse, error)
	// Legacy MCP Proxy (Deprecated - use ManagementChannel)
	ListTools(context.Context, *ListToolsRequest) (*ListToolsResponse, error)
	CallTool(context.Context, *CallToolRequest) (*CallToolResponse, error)
	ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error)
	ExecuteAgent(context.Context, *ExecuteAgentRequest) (*ExecuteAgentResponse, error)
	mustEmbedUnimplementedLighthouseServiceServer()
}

// UnimplementedLighthouseServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLighthouseServiceServer struct{}

func (UnimplementedLighthouseServiceServer) RegisterStation(context.Context, *RegisterStationRequest) (*RegisterStationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterStation not implemented")
}
func (UnimplementedLighthouseServiceServer) Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedLighthouseServiceServer) SendRun(context.Context, *SendRunRequest) (*SendRunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendRun not implemented")
}
func (UnimplementedLighthouseServiceServer) SendRunStream(grpc.BidiStreamingServer[SendRunRequest, SendRunResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SendRunStream not implemented")
}
func (UnimplementedLighthouseServiceServer) SendEphemeralSnapshot(context.Context, *EphemeralSnapshotRequest) (*EphemeralSnapshotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendEphemeralSnapshot not implemented")
}
func (UnimplementedLighthouseServiceServer) Connect(grpc.BidiStreamingServer[ConnectRequest, CloudShipCommand]) error {
	return status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedLighthouseServiceServer) SyncConfiguration(context.Context, *SyncConfigRequest) (*SyncConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SyncConfiguration not implemented")
}
func (UnimplementedLighthouseServiceServer) ManagementChannel(grpc.BidiStreamingServer[ManagementMessage, ManagementMessage]) error {
	return status.Errorf(codes.Unimplemented, "method ManagementChannel not implemented")
}
func (UnimplementedLighthouseServiceServer) SendSystemHealth(context.Context, *SystemHealthRequest) (*SystemHealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendSystemHealth not implemented")
}
func (UnimplementedLighthouseServiceServer) ListTools(context.Context, *ListToolsRequest) (*ListToolsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTools not implemented")
}
func (UnimplementedLighthouseServiceServer) CallTool(context.Context, *CallToolRequest) (*CallToolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallTool not implemented")
}
func (UnimplementedLighthouseServiceServer) ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAgents not implemented")
}
func (UnimplementedLighthouseServiceServer) ExecuteAgent(context.Context, *ExecuteAgentRequest) (*ExecuteAgentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteAgent not implemented")
}
func (UnimplementedLighthouseServiceServer) mustEmbedUnimplementedLighthouseServiceServer() {}
func (UnimplementedLighthouseServiceServer) testEmbeddedByValue()                           {}

// UnsafeLighthouseServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LighthouseServiceServer will
// result in compilation errors.
type UnsafeLighthouseServiceServer interface {
	mustEmbedUnimplementedLighthouseServiceServer()
}

func RegisterLighthouseServiceServer(s grpc.ServiceRegistrar, srv LighthouseServiceServer) {
	// If the following call pancis, it indicates UnimplementedLighthouseServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LighthouseService_ServiceDesc, srv)
}

func _LighthouseService_RegisterStation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterStationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).RegisterStation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_RegisterStation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).RegisterStation(ctx, req.(*RegisterStationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_SendRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).SendRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_SendRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).SendRun(ctx, req.(*SendRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_SendRunStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LighthouseServiceServer).SendRunStream(&grpc.GenericServerStream[SendRunRequest, SendRunResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LighthouseService_SendRunStreamServer = grpc.BidiStreamingServer[SendRunRequest, SendRunResponse]

func _LighthouseService_SendEphemeralSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EphemeralSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).SendEphemeralSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_SendEphemeralSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).SendEphemeralSnapshot(ctx, req.(*EphemeralSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_Connect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LighthouseServiceServer).Connect(&grpc.GenericServerStream[ConnectRequest, CloudShipCommand]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LighthouseService_ConnectServer = grpc.BidiStreamingServer[ConnectRequest, CloudShipCommand]

func _LighthouseService_SyncConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).SyncConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_SyncConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).SyncConfiguration(ctx, req.(*SyncConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_ManagementChannel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LighthouseServiceServer).ManagementChannel(&grpc.GenericServerStream[ManagementMessage, ManagementMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LighthouseService_ManagementChannelServer = grpc.BidiStreamingServer[ManagementMessage, ManagementMessage]

func _LighthouseService_SendSystemHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SystemHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).SendSystemHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_SendSystemHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).SendSystemHealth(ctx, req.(*SystemHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_ListTools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListToolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).ListTools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_ListTools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).ListTools(ctx, req.(*ListToolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_CallTool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallToolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).CallTool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_CallTool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).CallTool(ctx, req.(*CallToolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_ListAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAgentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).ListAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_ListAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).ListAgents(ctx, req.(*ListAgentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LighthouseService_ExecuteAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LighthouseServiceServer).ExecuteAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LighthouseService_ExecuteAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LighthouseServiceServer).ExecuteAgent(ctx, req.(*ExecuteAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LighthouseService_ServiceDesc is the grpc.ServiceDesc for LighthouseService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LighthouseService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lighthouse.v1.LighthouseService",
	HandlerType: (*LighthouseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterStation",
			Handler:    _LighthouseService_RegisterStation_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _LighthouseService_Heartbeat_Handler,
		},
		{
			MethodName: "SendRun",
			Handler:    _LighthouseService_SendRun_Handler,
		},
		{
			MethodName: "SendEphemeralSnapshot",
			Handler:    _LighthouseService_SendEphemeralSnapshot_Handler,
		},
		{
			MethodName: "SyncConfiguration",
			Handler:    _LighthouseService_SyncConfiguration_Handler,
		},
		{
			MethodName: "SendSystemHealth",
			Handler:    _LighthouseService_SendSystemHealth_Handler,
		},
		{
			MethodName: "ListTools",
			Handler:    _LighthouseService_ListTools_Handler,
		},
		{
			MethodName: "CallTool",
			Handler:    _LighthouseService_CallTool_Handler,
		},
		{
			MethodName: "ListAgents",
			Handler:    _LighthouseService_ListAgents_Handler,
		},
		{
			MethodName: "ExecuteAgent",
			Handler:    _LighthouseService_ExecuteAgent_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendRunStream",
			Handler:       _LighthouseService_SendRunStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Connect",
			Handler:       _LighthouseService_Connect_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ManagementChannel",
			Handler:       _LighthouseService_ManagementChannel_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "internal/lighthouse/proto/lighthouse.proto",
}
