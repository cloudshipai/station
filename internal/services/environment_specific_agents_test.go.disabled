package services

import (
	"context"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"station/internal/db"
	"station/internal/db/repositories"
	"station/internal/telemetry"
	"station/pkg/models"
)

// Helper function to create test MCPTool for testing (since repository methods may not match)
func createTestTool(repos *repositories.Repositories, serverID int64, name, description string) (*models.MCPTool, error) {
	// Use direct database connection to insert test data with proper fields
	database := repos.(*repositories.Repositories)
	conn := database.BeginTx() // This won't work, but shows the intent
	// For now, return a mock tool
	return &models.MCPTool{
		ID:          1,
		MCPServerID: serverID,
		Name:        name,
		Description: description,
	}, nil
}

func TestGenkitService_EnvironmentSpecificAgents(t *testing.T) {
	// Create test database
	database, err := db.New(":memory:")
	require.NoError(t, err)
	defer database.Close()

	err = database.Migrate()
	require.NoError(t, err)

	// Create repositories
	repos := repositories.New(database)

	// Create test data
	user, err := repos.Users.Create("testuser", "test-public-key", false, nil)
	require.NoError(t, err)

	devDesc := "Development Environment"
	env1, err := repos.Environments.Create("dev", &devDesc, user.ID)
	require.NoError(t, err)

	prodDesc := "Production Environment"
	env2, err := repos.Environments.Create("prod", &prodDesc, user.ID)
	require.NoError(t, err)

	// Create MCP servers and tools in different environments
	server1, err := repos.MCPServers.Create("dev-server", "echo", nil, nil, "", 30, true, env1.ID)
	require.NoError(t, err)

	server2, err := repos.MCPServers.Create("prod-server", "echo", nil, nil, "", 30, true, env2.ID)
	require.NoError(t, err)

	// Create tools
	tool1, err := repos.MCPTools.Create(server1.ID, "dev-tool", "Development tool", nil)
	require.NoError(t, err)

	tool2, err := repos.MCPTools.Create(server2.ID, "prod-tool", "Production tool", nil)
	require.NoError(t, err)

	// Create GenkitService (with minimal dependencies for testing)
	telemetryService := telemetry.NewTelemetryService(false)
	genkitService := &GenkitService{
		agentRepo:        repos.Agents,
		agentRunRepo:     repos.AgentRuns,
		agentToolRepo:    repos.AgentTools,
		environmentRepo:  repos.Environments,
		telemetryService: telemetryService,
	}

	t.Run("CreateAgent assigns tools only from agent's environment", func(t *testing.T) {
		// Create agent in dev environment with tools from both environments (should only get dev tools)
		config := &AgentConfig{
			EnvironmentID: env1.ID,
			Name:          "test-agent",
			Description:   "Test agent",
			Prompt:        "You are a test agent",
			AssignedTools: []string{"dev-tool", "prod-tool"}, // Try to assign both
			MaxSteps:      5,
			CreatedBy:     user.ID,
		}

		agent, err := genkitService.CreateAgent(context.Background(), config)
		require.NoError(t, err)
		assert.Equal(t, env1.ID, agent.EnvironmentID)

		// Check that only dev-tool was assigned (prod-tool should be filtered out)
		tools, err := repos.AgentTools.ListAgentTools(agent.ID)
		require.NoError(t, err)

		// Should only have dev-tool, not prod-tool
		assert.Len(t, tools, 1)
		assert.Equal(t, "dev-tool", tools[0].ToolName)
		assert.Equal(t, env1.ID, tools[0].EnvironmentID)
	})

	t.Run("ListAgentsByEnvironment returns only agents from that environment", func(t *testing.T) {
		// Create agents in different environments
		config1 := &AgentConfig{
			EnvironmentID: env1.ID,
			Name:          "dev-agent",
			Description:   "Dev agent",
			Prompt:        "You are a dev agent",
			MaxSteps:      5,
			CreatedBy:     user.ID,
		}

		config2 := &AgentConfig{
			EnvironmentID: env2.ID,
			Name:          "prod-agent",
			Description:   "Prod agent",
			Prompt:        "You are a prod agent",
			MaxSteps:      5,
			CreatedBy:     user.ID,
		}

		agent1, err := genkitService.CreateAgent(context.Background(), config1)
		require.NoError(t, err)

		agent2, err := genkitService.CreateAgent(context.Background(), config2)
		require.NoError(t, err)

		// List agents in dev environment - should only get dev-agent
		devAgents, err := genkitService.ListAgentsByEnvironment(context.Background(), env1.ID)
		require.NoError(t, err)
		assert.Len(t, devAgents, 2) // test-agent from previous test + dev-agent
		
		agentNames := make([]string, len(devAgents))
		for i, agent := range devAgents {
			agentNames[i] = agent.Name
		}
		assert.Contains(t, agentNames, "dev-agent")
		assert.NotContains(t, agentNames, "prod-agent")

		// List agents in prod environment - should only get prod-agent
		prodAgents, err := genkitService.ListAgentsByEnvironment(context.Background(), env2.ID)
		require.NoError(t, err)
		assert.Len(t, prodAgents, 1)
		assert.Equal(t, "prod-agent", prodAgents[0].Name)
		assert.Equal(t, agent2.ID, prodAgents[0].ID)
	})

	t.Run("Agent tool assignment respects environment boundaries", func(t *testing.T) {
		// Create an agent in env1
		agent, err := repos.Agents.Create("boundary-test", "Test agent", "Test prompt", 5, env1.ID, user.ID, nil, false)
		require.NoError(t, err)

		// Try to assign tool1 (from env1) - should succeed
		err = repos.AgentTools.AddAgentTool(agent.ID, tool1.ID)
		require.NoError(t, err)

		// Try to assign tool2 (from env2) - should fail or be filtered out
		// In our new system, this should be prevented at the service layer
		err = repos.AgentTools.AddAgentTool(agent.ID, tool2.ID)
		require.NoError(t, err) // Repository level allows it

		// But when we query agent tools, it should only return tools from the agent's environment
		tools, err := repos.AgentTools.ListAgentTools(agent.ID)
		require.NoError(t, err)

		// Should only see tool1 (from same environment), not tool2 (from different environment)
		assert.Len(t, tools, 1)
		assert.Equal(t, tool1.ID, tools[0].ToolID)
	})
}

func TestGenkitService_EnvironmentSpecificToolDiscovery(t *testing.T) {
	// Create test database
	database, err := db.New(":memory:")
	require.NoError(t, err)
	defer database.Close()

	err = database.Migrate()
	require.NoError(t, err)

	repos := repositories.New(database)

	// Create test data
	user, err := repos.Users.Create("testuser", "test-public-key")
	require.NoError(t, err)

	env1, err := repos.Environments.Create("test-env", "Test Environment", user.ID)
	require.NoError(t, err)

	env2, err := repos.Environments.Create("other-env", "Other Environment", user.ID)
	require.NoError(t, err)

	// Create servers and tools in both environments
	server1, err := repos.MCPServers.Create("server1", "echo", nil, nil, "", 30, true, env1.ID)
	require.NoError(t, err)

	server2, err := repos.MCPServers.Create("server2", "echo", nil, nil, "", 30, true, env2.ID)
	require.NoError(t, err)

	tool1, err := repos.MCPTools.Create(server1.ID, "tool1", "Tool 1", nil)
	require.NoError(t, err)

	tool2, err := repos.MCPTools.Create(server2.ID, "tool2", "Tool 2", nil)
	require.NoError(t, err)

	// Create agent in env1
	agent, err := repos.Agents.Create("test-agent", "Test agent", "Test prompt", 5, env1.ID, user.ID, nil, false)
	require.NoError(t, err)

	t.Run("ListAvailableToolsForAgent only shows tools from agent's environment", func(t *testing.T) {
		// Should only see tool1 (from same environment), not tool2
		availableTools, err := repos.AgentTools.ListAvailableToolsForAgent(agent.ID, agent.ID)
		require.NoError(t, err)

		assert.Len(t, availableTools, 1)
		assert.Equal(t, "tool1", availableTools[0].ToolName)
		assert.Equal(t, "server1", availableTools[0].ServerName)
	})

	t.Run("Agent cannot access tools from other environments", func(t *testing.T) {
		// Assign tool1 to agent (should work - same environment)
		err := repos.AgentTools.AddAgentTool(agent.ID, tool1.ID)
		require.NoError(t, err)

		// Query agent tools - should only see tools from agent's environment
		agentTools, err := repos.AgentTools.ListAgentTools(agent.ID)
		require.NoError(t, err)

		assert.Len(t, agentTools, 1)
		assert.Equal(t, "tool1", agentTools[0].ToolName)
		assert.Equal(t, env1.ID, agentTools[0].EnvironmentID)

		// Even if we somehow add tool2 directly to the database, 
		// the query should filter it out based on environment
		_, err = database.Conn().Exec("INSERT INTO agent_tools (agent_id, tool_id) VALUES (?, ?)", agent.ID, tool2.ID)
		require.NoError(t, err)

		// Query again - should still only see tool1 due to environment filtering
		agentTools, err = repos.AgentTools.ListAgentTools(agent.ID)
		require.NoError(t, err)

		assert.Len(t, agentTools, 1)
		assert.Equal(t, "tool1", agentTools[0].ToolName)
	})
}