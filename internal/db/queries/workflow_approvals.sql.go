// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: workflow_approvals.sql

package queries

import (
	"context"
	"database/sql"
)

const approveWorkflowApproval = `-- name: ApproveWorkflowApproval :exec
UPDATE workflow_approvals
SET
    status = 'approved',
    decided_by = ?1,
    decided_at = CURRENT_TIMESTAMP,
    decision_reason = ?2,
    updated_at = CURRENT_TIMESTAMP
WHERE approval_id = ?3
  AND status = 'pending'
`

type ApproveWorkflowApprovalParams struct {
	DecidedBy      sql.NullString `json:"decided_by"`
	DecisionReason sql.NullString `json:"decision_reason"`
	ApprovalID     string         `json:"approval_id"`
}

func (q *Queries) ApproveWorkflowApproval(ctx context.Context, arg ApproveWorkflowApprovalParams) error {
	_, err := q.db.ExecContext(ctx, approveWorkflowApproval, arg.DecidedBy, arg.DecisionReason, arg.ApprovalID)
	return err
}

const getWorkflowApproval = `-- name: GetWorkflowApproval :one
SELECT id, approval_id, run_id, step_id, message, summary_path, approvers, status, decided_by, decided_at, decision_reason, timeout_at, created_at, updated_at
FROM workflow_approvals
WHERE approval_id = ?1
`

func (q *Queries) GetWorkflowApproval(ctx context.Context, approvalID string) (WorkflowApproval, error) {
	row := q.db.QueryRowContext(ctx, getWorkflowApproval, approvalID)
	var i WorkflowApproval
	err := row.Scan(
		&i.ID,
		&i.ApprovalID,
		&i.RunID,
		&i.StepID,
		&i.Message,
		&i.SummaryPath,
		&i.Approvers,
		&i.Status,
		&i.DecidedBy,
		&i.DecidedAt,
		&i.DecisionReason,
		&i.TimeoutAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertWorkflowApproval = `-- name: InsertWorkflowApproval :one
INSERT INTO workflow_approvals (
    approval_id,
    run_id,
    step_id,
    message,
    summary_path,
    approvers,
    status,
    timeout_at
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8
)
RETURNING id, approval_id, run_id, step_id, message, summary_path, approvers, status, decided_by, decided_at, decision_reason, timeout_at, created_at, updated_at
`

type InsertWorkflowApprovalParams struct {
	ApprovalID  string         `json:"approval_id"`
	RunID       string         `json:"run_id"`
	StepID      string         `json:"step_id"`
	Message     string         `json:"message"`
	SummaryPath sql.NullString `json:"summary_path"`
	Approvers   sql.NullString `json:"approvers"`
	Status      string         `json:"status"`
	TimeoutAt   sql.NullTime   `json:"timeout_at"`
}

func (q *Queries) InsertWorkflowApproval(ctx context.Context, arg InsertWorkflowApprovalParams) (WorkflowApproval, error) {
	row := q.db.QueryRowContext(ctx, insertWorkflowApproval,
		arg.ApprovalID,
		arg.RunID,
		arg.StepID,
		arg.Message,
		arg.SummaryPath,
		arg.Approvers,
		arg.Status,
		arg.TimeoutAt,
	)
	var i WorkflowApproval
	err := row.Scan(
		&i.ID,
		&i.ApprovalID,
		&i.RunID,
		&i.StepID,
		&i.Message,
		&i.SummaryPath,
		&i.Approvers,
		&i.Status,
		&i.DecidedBy,
		&i.DecidedAt,
		&i.DecisionReason,
		&i.TimeoutAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPendingApprovals = `-- name: ListPendingApprovals :many
SELECT id, approval_id, run_id, step_id, message, summary_path, approvers, status, decided_by, decided_at, decision_reason, timeout_at, created_at, updated_at
FROM workflow_approvals
WHERE status = 'pending'
ORDER BY created_at ASC
LIMIT ?1
`

func (q *Queries) ListPendingApprovals(ctx context.Context, limit int64) ([]WorkflowApproval, error) {
	rows, err := q.db.QueryContext(ctx, listPendingApprovals, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowApproval
	for rows.Next() {
		var i WorkflowApproval
		if err := rows.Scan(
			&i.ID,
			&i.ApprovalID,
			&i.RunID,
			&i.StepID,
			&i.Message,
			&i.SummaryPath,
			&i.Approvers,
			&i.Status,
			&i.DecidedBy,
			&i.DecidedAt,
			&i.DecisionReason,
			&i.TimeoutAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkflowApprovals = `-- name: ListWorkflowApprovals :many
SELECT id, approval_id, run_id, step_id, message, summary_path, approvers, status, decided_by, decided_at, decision_reason, timeout_at, created_at, updated_at
FROM workflow_approvals
WHERE run_id = ?1
ORDER BY created_at ASC
`

func (q *Queries) ListWorkflowApprovals(ctx context.Context, runID string) ([]WorkflowApproval, error) {
	rows, err := q.db.QueryContext(ctx, listWorkflowApprovals, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowApproval
	for rows.Next() {
		var i WorkflowApproval
		if err := rows.Scan(
			&i.ID,
			&i.ApprovalID,
			&i.RunID,
			&i.StepID,
			&i.Message,
			&i.SummaryPath,
			&i.Approvers,
			&i.Status,
			&i.DecidedBy,
			&i.DecidedAt,
			&i.DecisionReason,
			&i.TimeoutAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectWorkflowApproval = `-- name: RejectWorkflowApproval :exec
UPDATE workflow_approvals
SET
    status = 'rejected',
    decided_by = ?1,
    decided_at = CURRENT_TIMESTAMP,
    decision_reason = ?2,
    updated_at = CURRENT_TIMESTAMP
WHERE approval_id = ?3
  AND status = 'pending'
`

type RejectWorkflowApprovalParams struct {
	DecidedBy      sql.NullString `json:"decided_by"`
	DecisionReason sql.NullString `json:"decision_reason"`
	ApprovalID     string         `json:"approval_id"`
}

func (q *Queries) RejectWorkflowApproval(ctx context.Context, arg RejectWorkflowApprovalParams) error {
	_, err := q.db.ExecContext(ctx, rejectWorkflowApproval, arg.DecidedBy, arg.DecisionReason, arg.ApprovalID)
	return err
}

const timeoutExpiredApprovals = `-- name: TimeoutExpiredApprovals :exec
UPDATE workflow_approvals
SET
    status = 'timed_out',
    updated_at = CURRENT_TIMESTAMP
WHERE status = 'pending'
  AND timeout_at IS NOT NULL
  AND timeout_at < CURRENT_TIMESTAMP
`

func (q *Queries) TimeoutExpiredApprovals(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, timeoutExpiredApprovals)
	return err
}
