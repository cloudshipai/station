// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notification_logs.sql

package queries

import (
	"context"
	"database/sql"
)

const countNotificationLogsByApproval = `-- name: CountNotificationLogsByApproval :one
SELECT COUNT(*) as count
FROM notification_logs
WHERE approval_id = ?1
`

func (q *Queries) CountNotificationLogsByApproval(ctx context.Context, approvalID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNotificationLogsByApproval, approvalID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteOldNotificationLogs = `-- name: DeleteOldNotificationLogs :exec
DELETE FROM notification_logs
WHERE created_at < ?1
`

func (q *Queries) DeleteOldNotificationLogs(ctx context.Context, before sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, deleteOldNotificationLogs, before)
	return err
}

const getNotificationLog = `-- name: GetNotificationLog :one
SELECT id, log_id, approval_id, event_type, webhook_url, request_payload, response_status, response_body, error_message, attempt_number, duration_ms, created_at
FROM notification_logs
WHERE log_id = ?1
`

func (q *Queries) GetNotificationLog(ctx context.Context, logID string) (NotificationLog, error) {
	row := q.db.QueryRowContext(ctx, getNotificationLog, logID)
	var i NotificationLog
	err := row.Scan(
		&i.ID,
		&i.LogID,
		&i.ApprovalID,
		&i.EventType,
		&i.WebhookUrl,
		&i.RequestPayload,
		&i.ResponseStatus,
		&i.ResponseBody,
		&i.ErrorMessage,
		&i.AttemptNumber,
		&i.DurationMs,
		&i.CreatedAt,
	)
	return i, err
}

const insertNotificationLog = `-- name: InsertNotificationLog :one
INSERT INTO notification_logs (
    log_id,
    approval_id,
    event_type,
    webhook_url,
    request_payload,
    response_status,
    response_body,
    error_message,
    attempt_number,
    duration_ms
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9,
    ?10
)
RETURNING id, log_id, approval_id, event_type, webhook_url, request_payload, response_status, response_body, error_message, attempt_number, duration_ms, created_at
`

type InsertNotificationLogParams struct {
	LogID          string         `json:"log_id"`
	ApprovalID     string         `json:"approval_id"`
	EventType      string         `json:"event_type"`
	WebhookUrl     sql.NullString `json:"webhook_url"`
	RequestPayload sql.NullString `json:"request_payload"`
	ResponseStatus sql.NullInt64  `json:"response_status"`
	ResponseBody   sql.NullString `json:"response_body"`
	ErrorMessage   sql.NullString `json:"error_message"`
	AttemptNumber  sql.NullInt64  `json:"attempt_number"`
	DurationMs     sql.NullInt64  `json:"duration_ms"`
}

func (q *Queries) InsertNotificationLog(ctx context.Context, arg InsertNotificationLogParams) (NotificationLog, error) {
	row := q.db.QueryRowContext(ctx, insertNotificationLog,
		arg.LogID,
		arg.ApprovalID,
		arg.EventType,
		arg.WebhookUrl,
		arg.RequestPayload,
		arg.ResponseStatus,
		arg.ResponseBody,
		arg.ErrorMessage,
		arg.AttemptNumber,
		arg.DurationMs,
	)
	var i NotificationLog
	err := row.Scan(
		&i.ID,
		&i.LogID,
		&i.ApprovalID,
		&i.EventType,
		&i.WebhookUrl,
		&i.RequestPayload,
		&i.ResponseStatus,
		&i.ResponseBody,
		&i.ErrorMessage,
		&i.AttemptNumber,
		&i.DurationMs,
		&i.CreatedAt,
	)
	return i, err
}

const listNotificationLogsByApproval = `-- name: ListNotificationLogsByApproval :many
SELECT id, log_id, approval_id, event_type, webhook_url, request_payload, response_status, response_body, error_message, attempt_number, duration_ms, created_at
FROM notification_logs
WHERE approval_id = ?1
ORDER BY created_at ASC
`

func (q *Queries) ListNotificationLogsByApproval(ctx context.Context, approvalID string) ([]NotificationLog, error) {
	rows, err := q.db.QueryContext(ctx, listNotificationLogsByApproval, approvalID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotificationLog
	for rows.Next() {
		var i NotificationLog
		if err := rows.Scan(
			&i.ID,
			&i.LogID,
			&i.ApprovalID,
			&i.EventType,
			&i.WebhookUrl,
			&i.RequestPayload,
			&i.ResponseStatus,
			&i.ResponseBody,
			&i.ErrorMessage,
			&i.AttemptNumber,
			&i.DurationMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotificationLogsByEventType = `-- name: ListNotificationLogsByEventType :many
SELECT id, log_id, approval_id, event_type, webhook_url, request_payload, response_status, response_body, error_message, attempt_number, duration_ms, created_at
FROM notification_logs
WHERE event_type = ?1
ORDER BY created_at DESC
LIMIT ?2
`

type ListNotificationLogsByEventTypeParams struct {
	EventType string `json:"event_type"`
	Limit     int64  `json:"limit"`
}

func (q *Queries) ListNotificationLogsByEventType(ctx context.Context, arg ListNotificationLogsByEventTypeParams) ([]NotificationLog, error) {
	rows, err := q.db.QueryContext(ctx, listNotificationLogsByEventType, arg.EventType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotificationLog
	for rows.Next() {
		var i NotificationLog
		if err := rows.Scan(
			&i.ID,
			&i.LogID,
			&i.ApprovalID,
			&i.EventType,
			&i.WebhookUrl,
			&i.RequestPayload,
			&i.ResponseStatus,
			&i.ResponseBody,
			&i.ErrorMessage,
			&i.AttemptNumber,
			&i.DurationMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentNotificationLogs = `-- name: ListRecentNotificationLogs :many
SELECT id, log_id, approval_id, event_type, webhook_url, request_payload, response_status, response_body, error_message, attempt_number, duration_ms, created_at
FROM notification_logs
ORDER BY created_at DESC
LIMIT ?1
`

func (q *Queries) ListRecentNotificationLogs(ctx context.Context, limit int64) ([]NotificationLog, error) {
	rows, err := q.db.QueryContext(ctx, listRecentNotificationLogs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NotificationLog
	for rows.Next() {
		var i NotificationLog
		if err := rows.Scan(
			&i.ID,
			&i.LogID,
			&i.ApprovalID,
			&i.EventType,
			&i.WebhookUrl,
			&i.RequestPayload,
			&i.ResponseStatus,
			&i.ResponseBody,
			&i.ErrorMessage,
			&i.AttemptNumber,
			&i.DurationMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
