// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: workflow_runs.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
)

const countWorkflowRuns = `-- name: CountWorkflowRuns :one
SELECT COUNT(*) FROM workflow_runs
`

func (q *Queries) CountWorkflowRuns(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countWorkflowRuns)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteAllWorkflowRuns = `-- name: DeleteAllWorkflowRuns :exec
DELETE FROM workflow_runs
`

func (q *Queries) DeleteAllWorkflowRuns(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllWorkflowRuns)
	return err
}

const deleteWorkflowRun = `-- name: DeleteWorkflowRun :exec
DELETE FROM workflow_runs WHERE run_id = ?1
`

func (q *Queries) DeleteWorkflowRun(ctx context.Context, runID string) error {
	_, err := q.db.ExecContext(ctx, deleteWorkflowRun, runID)
	return err
}

const deleteWorkflowRunsByIDs = `-- name: DeleteWorkflowRunsByIDs :exec
DELETE FROM workflow_runs WHERE run_id IN (/*SLICE:run_ids*/?)
`

func (q *Queries) DeleteWorkflowRunsByIDs(ctx context.Context, runIds []string) error {
	query := deleteWorkflowRunsByIDs
	var queryParams []interface{}
	if len(runIds) > 0 {
		for _, v := range runIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:run_ids*/?", strings.Repeat(",?", len(runIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:run_ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const deleteWorkflowRunsByStatus = `-- name: DeleteWorkflowRunsByStatus :exec
DELETE FROM workflow_runs WHERE status = ?1
`

func (q *Queries) DeleteWorkflowRunsByStatus(ctx context.Context, status string) error {
	_, err := q.db.ExecContext(ctx, deleteWorkflowRunsByStatus, status)
	return err
}

const deleteWorkflowRunsByWorkflowID = `-- name: DeleteWorkflowRunsByWorkflowID :exec
DELETE FROM workflow_runs WHERE workflow_id = ?1
`

func (q *Queries) DeleteWorkflowRunsByWorkflowID(ctx context.Context, workflowID string) error {
	_, err := q.db.ExecContext(ctx, deleteWorkflowRunsByWorkflowID, workflowID)
	return err
}

const getWorkflowRun = `-- name: GetWorkflowRun :one
SELECT id, run_id, workflow_id, workflow_version, status, current_step, input, context, result, error, summary, options, last_signal, created_at, updated_at, started_at, completed_at
FROM workflow_runs
WHERE run_id = ?1
`

func (q *Queries) GetWorkflowRun(ctx context.Context, runID string) (WorkflowRun, error) {
	row := q.db.QueryRowContext(ctx, getWorkflowRun, runID)
	var i WorkflowRun
	err := row.Scan(
		&i.ID,
		&i.RunID,
		&i.WorkflowID,
		&i.WorkflowVersion,
		&i.Status,
		&i.CurrentStep,
		&i.Input,
		&i.Context,
		&i.Result,
		&i.Error,
		&i.Summary,
		&i.Options,
		&i.LastSignal,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const insertWorkflowRun = `-- name: InsertWorkflowRun :one
INSERT INTO workflow_runs (
    run_id,
    workflow_id,
    workflow_version,
    status,
    current_step,
    input,
    context,
    result,
    error,
    summary,
    options,
    last_signal,
    started_at,
    completed_at
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9,
    ?10,
    ?11,
    ?12,
    COALESCE(?13, CURRENT_TIMESTAMP),
    ?14
)
RETURNING id, run_id, workflow_id, workflow_version, status, current_step, input, context, result, error, summary, options, last_signal, created_at, updated_at, started_at, completed_at
`

type InsertWorkflowRunParams struct {
	RunID           string         `json:"run_id"`
	WorkflowID      string         `json:"workflow_id"`
	WorkflowVersion int64          `json:"workflow_version"`
	Status          string         `json:"status"`
	CurrentStep     sql.NullString `json:"current_step"`
	Input           sql.NullString `json:"input"`
	Context         sql.NullString `json:"context"`
	Result          sql.NullString `json:"result"`
	Error           sql.NullString `json:"error"`
	Summary         sql.NullString `json:"summary"`
	Options         sql.NullString `json:"options"`
	LastSignal      sql.NullString `json:"last_signal"`
	StartedAt       interface{}    `json:"started_at"`
	CompletedAt     sql.NullTime   `json:"completed_at"`
}

func (q *Queries) InsertWorkflowRun(ctx context.Context, arg InsertWorkflowRunParams) (WorkflowRun, error) {
	row := q.db.QueryRowContext(ctx, insertWorkflowRun,
		arg.RunID,
		arg.WorkflowID,
		arg.WorkflowVersion,
		arg.Status,
		arg.CurrentStep,
		arg.Input,
		arg.Context,
		arg.Result,
		arg.Error,
		arg.Summary,
		arg.Options,
		arg.LastSignal,
		arg.StartedAt,
		arg.CompletedAt,
	)
	var i WorkflowRun
	err := row.Scan(
		&i.ID,
		&i.RunID,
		&i.WorkflowID,
		&i.WorkflowVersion,
		&i.Status,
		&i.CurrentStep,
		&i.Input,
		&i.Context,
		&i.Result,
		&i.Error,
		&i.Summary,
		&i.Options,
		&i.LastSignal,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listWorkflowRuns = `-- name: ListWorkflowRuns :many
SELECT id, run_id, workflow_id, workflow_version, status, current_step, input, context, result, error, summary, options, last_signal, created_at, updated_at, started_at, completed_at
FROM workflow_runs
WHERE (?1 IS NULL OR workflow_id = ?1)
  AND (?2 IS NULL OR status = ?2)
ORDER BY created_at DESC
LIMIT ?3
`

type ListWorkflowRunsParams struct {
	WorkflowID interface{} `json:"workflow_id"`
	Status     interface{} `json:"status"`
	Limit      int64       `json:"limit"`
}

func (q *Queries) ListWorkflowRuns(ctx context.Context, arg ListWorkflowRunsParams) ([]WorkflowRun, error) {
	rows, err := q.db.QueryContext(ctx, listWorkflowRuns, arg.WorkflowID, arg.Status, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowRun
	for rows.Next() {
		var i WorkflowRun
		if err := rows.Scan(
			&i.ID,
			&i.RunID,
			&i.WorkflowID,
			&i.WorkflowVersion,
			&i.Status,
			&i.CurrentStep,
			&i.Input,
			&i.Context,
			&i.Result,
			&i.Error,
			&i.Summary,
			&i.Options,
			&i.LastSignal,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWorkflowRunStatus = `-- name: UpdateWorkflowRunStatus :exec
UPDATE workflow_runs
SET
    status = ?1,
    current_step = ?2,
    context = COALESCE(?3, context),
    result = COALESCE(?4, result),
    error = ?5,
    summary = COALESCE(?6, summary),
    options = COALESCE(?7, options),
    last_signal = COALESCE(?8, last_signal),
    updated_at = CURRENT_TIMESTAMP,
    completed_at = COALESCE(?9, completed_at)
WHERE run_id = ?10
`

type UpdateWorkflowRunStatusParams struct {
	Status      string         `json:"status"`
	CurrentStep sql.NullString `json:"current_step"`
	Context     sql.NullString `json:"context"`
	Result      sql.NullString `json:"result"`
	Error       sql.NullString `json:"error"`
	Summary     sql.NullString `json:"summary"`
	Options     sql.NullString `json:"options"`
	LastSignal  sql.NullString `json:"last_signal"`
	CompletedAt sql.NullTime   `json:"completed_at"`
	RunID       string         `json:"run_id"`
}

func (q *Queries) UpdateWorkflowRunStatus(ctx context.Context, arg UpdateWorkflowRunStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateWorkflowRunStatus,
		arg.Status,
		arg.CurrentStep,
		arg.Context,
		arg.Result,
		arg.Error,
		arg.Summary,
		arg.Options,
		arg.LastSignal,
		arg.CompletedAt,
		arg.RunID,
	)
	return err
}
