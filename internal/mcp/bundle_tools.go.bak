package mcp

import (
	"context"
	"encoding/json"
	"fmt"
	"log"

	"station/pkg/bundle"
	bundlecli "station/pkg/bundle/cli"
)

// BundleToolsHandler provides MCP tools for bundle management
type BundleToolsHandler struct {
	bundleCLI *bundlecli.BundleCLI
}

// NewBundleToolsHandler creates a new bundle tools handler
func NewBundleToolsHandler() *BundleToolsHandler {
	return &BundleToolsHandler{
		bundleCLI: bundlecli.NewBundleCLI(nil),
	}
}

// CreateBundleRequest represents the input for creating a bundle
type CreateBundleRequest struct {
	BundlePath      string `json:"bundlePath" description:"Path where the bundle will be created"`
	Name            string `json:"name,omitempty" description:"Name of the bundle (optional)"`
	Description     string `json:"description,omitempty" description:"Description of the bundle (optional)"`
	FromEnvironment string `json:"fromEnvironment,omitempty" description:"Create bundle from existing environment (optional)"`
	Author          string `json:"author,omitempty" description:"Author of the bundle (optional)"`
	Version         string `json:"version,omitempty" description:"Version of the bundle (optional, defaults to 1.0.0)"`
}

// ValidateBundleRequest represents the input for validating a bundle
type ValidateBundleRequest struct {
	BundlePath string `json:"bundlePath" description:"Path to the bundle to validate"`
}

// PackageBundleRequest represents the input for packaging a bundle
type PackageBundleRequest struct {
	BundlePath    string `json:"bundlePath" description:"Path to the bundle to package"`
	OutputPath    string `json:"outputPath,omitempty" description:"Output path for the package (optional, defaults to bundle-name.tar.gz)"`
	ValidateFirst bool   `json:"validateFirst" description:"Validate bundle before packaging (default: true)"`
}

// BundleResponse represents a generic bundle operation response
type BundleResponse struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
	Error   string `json:"error,omitempty"`
}

// ValidationResponse represents a bundle validation response
type ValidationResponse struct {
	Success      bool                         `json:"success"`
	Valid        bool                         `json:"valid"`
	Issues       []bundle.ValidationIssue     `json:"issues,omitempty"`
	Warnings     []bundle.ValidationIssue     `json:"warnings,omitempty"`
	Message      string                       `json:"message"`
	Error        string                       `json:"error,omitempty"`
}

// PackageResponse represents a bundle packaging response
type PackageResponse struct {
	Success    bool   `json:"success"`
	OutputPath string `json:"outputPath,omitempty"`
	Size       int64  `json:"size,omitempty"`
	Message    string `json:"message"`
	Error      string `json:"error,omitempty"`
}

// CreateBundle creates a new bundle using the same service layer as 'stn template create'
func (h *BundleToolsHandler) CreateBundle(ctx context.Context, req CreateBundleRequest) (*BundleResponse, error) {
	log.Printf("MCP: Creating bundle at: %s", req.BundlePath)

	opts := bundle.CreateOptions{
		Name:            req.Name,
		Description:     req.Description,
		FromEnvironment: req.FromEnvironment,
		Author:          req.Author,
		Version:         req.Version,
	}

	// Use the same service layer as `stn template create`
	err := h.bundleCLI.CreateBundle(req.BundlePath, opts)
	if err != nil {
		return &BundleResponse{
			Success: false,
			Error:   err.Error(),
			Message: fmt.Sprintf("Failed to create bundle at '%s': %s", req.BundlePath, err.Error()),
		}, nil
	}

	return &BundleResponse{
		Success: true,
		Message: fmt.Sprintf("Successfully created bundle at: %s", req.BundlePath),
	}, nil
}

// ValidateBundle validates a bundle using the same service layer as 'stn template validate'
func (h *BundleToolsHandler) ValidateBundle(ctx context.Context, req ValidateBundleRequest) (*ValidationResponse, error) {
	log.Printf("MCP: Validating bundle: %s", req.BundlePath)

	// Use the same service layer as `stn template validate`
	summary, err := h.bundleCLI.ValidateBundle(req.BundlePath)
	if err != nil {
		return &ValidationResponse{
			Success: false,
			Error:   err.Error(),
			Message: fmt.Sprintf("Failed to validate bundle '%s': %s", req.BundlePath, err.Error()),
		}, nil
	}

	message := "Bundle validation completed"
	if summary.Valid {
		message = fmt.Sprintf("Bundle '%s' is valid and ready for packaging", req.BundlePath)
	} else {
		message = fmt.Sprintf("Bundle '%s' has %d issues that need to be fixed", req.BundlePath, len(summary.Issues))
	}

	return &ValidationResponse{
		Success:  true,
		Valid:    summary.Valid,
		Issues:   summary.Issues,
		Warnings: summary.Warnings,
		Message:  message,
	}, nil
}

// PackageBundle packages a bundle using the same service layer as 'stn template bundle'
func (h *BundleToolsHandler) PackageBundle(ctx context.Context, req PackageBundleRequest) (*PackageResponse, error) {
	log.Printf("MCP: Packaging bundle: %s", req.BundlePath)

	// Use the same service layer as `stn template bundle`
	summary, err := h.bundleCLI.PackageBundle(req.BundlePath, req.OutputPath, req.ValidateFirst)
	if err != nil {
		return &PackageResponse{
			Success: false,
			Error:   err.Error(),
			Message: fmt.Sprintf("Failed to package bundle '%s': %s", req.BundlePath, err.Error()),
		}, nil
	}

	if !summary.Success {
		return &PackageResponse{
			Success: false,
			Error:   summary.Error,
			Message: fmt.Sprintf("Bundle packaging failed: %s", summary.Error),
		}, nil
	}

	return &PackageResponse{
		Success:    true,
		OutputPath: summary.OutputPath,
		Size:       summary.Size,
		Message:    fmt.Sprintf("Successfully packaged bundle to: %s (size: %s)", summary.OutputPath, formatBytes(summary.Size)),
	}, nil
}

// GetAvailableTools returns the list of available bundle tools
func (h *BundleToolsHandler) GetAvailableTools() []ToolDefinition {
	return []ToolDefinition{
		{
			Name:        "create_bundle",
			Description: "Create a new template bundle using the same service layer as 'stn template create'",
			InputSchema: map[string]interface{}{
				"type": "object",
				"properties": map[string]interface{}{
					"bundlePath": map[string]interface{}{
						"type":        "string",
						"description": "Path where the bundle will be created",
					},
					"name": map[string]interface{}{
						"type":        "string",
						"description": "Name of the bundle (optional)",
					},
					"description": map[string]interface{}{
						"type":        "string",
						"description": "Description of the bundle (optional)",
					},
					"fromEnvironment": map[string]interface{}{
						"type":        "string",
						"description": "Create bundle from existing environment (optional)",
					},
					"author": map[string]interface{}{
						"type":        "string",
						"description": "Author of the bundle (optional)",
					},
					"version": map[string]interface{}{
						"type":        "string",
						"description": "Version of the bundle (optional, defaults to 1.0.0)",
						"default":     "1.0.0",
					},
				},
				"required": []string{"bundlePath"},
			},
		},
		{
			Name:        "validate_bundle",
			Description: "Validate a template bundle using the same service layer as 'stn template validate'",
			InputSchema: map[string]interface{}{
				"type": "object",
				"properties": map[string]interface{}{
					"bundlePath": map[string]interface{}{
						"type":        "string",
						"description": "Path to the bundle to validate",
					},
				},
				"required": []string{"bundlePath"},
			},
		},
		{
			Name:        "package_bundle",
			Description: "Package a template bundle for distribution using the same service layer as 'stn template bundle'",
			InputSchema: map[string]interface{}{
				"type": "object",
				"properties": map[string]interface{}{
					"bundlePath": map[string]interface{}{
						"type":        "string",
						"description": "Path to the bundle to package",
					},
					"outputPath": map[string]interface{}{
						"type":        "string",
						"description": "Output path for the package (optional, defaults to bundle-name.tar.gz)",
					},
					"validateFirst": map[string]interface{}{
						"type":        "boolean",
						"description": "Validate bundle before packaging",
						"default":     true,
					},
				},
				"required": []string{"bundlePath"},
			},
		},
	}
}

// HandleToolCall processes a tool call for bundle operations
func (h *BundleToolsHandler) HandleToolCall(ctx context.Context, name string, arguments map[string]interface{}) (interface{}, error) {
	switch name {
	case "create_bundle":
		// Parse arguments
		argBytes, err := json.Marshal(arguments)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal arguments: %w", err)
		}

		var req CreateBundleRequest
		if err := json.Unmarshal(argBytes, &req); err != nil {
			return nil, fmt.Errorf("failed to parse create_bundle arguments: %w", err)
		}

		return h.CreateBundle(ctx, req)

	case "validate_bundle":
		// Parse arguments
		argBytes, err := json.Marshal(arguments)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal arguments: %w", err)
		}

		var req ValidateBundleRequest
		if err := json.Unmarshal(argBytes, &req); err != nil {
			return nil, fmt.Errorf("failed to parse validate_bundle arguments: %w", err)
		}

		return h.ValidateBundle(ctx, req)

	case "package_bundle":
		// Parse arguments
		argBytes, err := json.Marshal(arguments)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal arguments: %w", err)
		}

		var req PackageBundleRequest
		if err := json.Unmarshal(argBytes, &req); err != nil {
			return nil, fmt.Errorf("failed to parse package_bundle arguments: %w", err)
		}

		return h.PackageBundle(ctx, req)

	default:
		return nil, fmt.Errorf("unknown tool: %s", name)
	}
}

// formatBytes formats bytes to human readable format
func formatBytes(bytes int64) string {
	const unit = 1024
	if bytes < unit {
		return fmt.Sprintf("%d B", bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])
}