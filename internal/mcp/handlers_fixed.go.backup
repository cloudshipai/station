package mcp

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"

	"station/pkg/models"

	"github.com/mark3labs/mcp-go/mcp"
)

// Simplified handlers that work with the current repository interfaces

func (s *Server) handleCreateAgent(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Extract parameters
	name, err := request.RequireString("name")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Missing 'name' parameter: %v", err)), nil
	}

	description, err := request.RequireString("description")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Missing 'description' parameter: %v", err)), nil
	}

	prompt, err := request.RequireString("prompt")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Missing 'prompt' parameter: %v", err)), nil
	}

	environmentIDStr, err := request.RequireString("environment_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Missing 'environment_id' parameter: %v", err)), nil
	}

	environmentID, err := strconv.ParseInt(environmentIDStr, 10, 64)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Invalid environment_id format: %v", err)), nil
	}

	// Extract optional parameters
	maxSteps := request.GetInt("max_steps", 5) // Default to 5 if not provided
	enabled := request.GetBool("enabled", true) // Default to true if not provided
	
	// Extract tool_names array if provided
	var toolNames []string
	if request.Params.Arguments != nil {
		if argsMap, ok := request.Params.Arguments.(map[string]interface{}); ok {
			if toolNamesArg, ok := argsMap["tool_names"]; ok {
				// Handle array parameter
				if toolNamesArray, ok := toolNamesArg.([]interface{}); ok {
					for _, toolName := range toolNamesArray {
						if str, ok := toolName.(string); ok {
							toolNames = append(toolNames, str)
						}
					}
				}
			}
		}
	}

	// Create the agent using repository with correct parameter order
	// Create(name, description, prompt string, maxSteps, environmentID, createdBy int64, cronSchedule *string, scheduleEnabled bool)
	createdAgent, err := s.repos.Agents.Create(name, description, prompt, int64(maxSteps), environmentID, 1, nil, enabled)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Failed to create agent: %v", err)), nil
	}

	// Assign tools to the agent if tool_names were provided
	var assignedTools []string
	var skippedTools []string
	if len(toolNames) > 0 {
		for _, toolName := range toolNames {
			// Find tool by name in the agent's environment
			tool, err := s.repos.MCPTools.FindByNameInEnvironment(environmentID, toolName)
			if err != nil {
				skippedTools = append(skippedTools, fmt.Sprintf("%s (not found in environment)", toolName))
				continue
			}
			
			// Assign tool to agent
			_, err = s.repos.AgentTools.AddAgentTool(createdAgent.ID, tool.ID)
			if err != nil {
				skippedTools = append(skippedTools, fmt.Sprintf("%s (assignment failed: %v)", toolName, err))
				continue
			}
			
			assignedTools = append(assignedTools, toolName)
		}
	}

	response := map[string]interface{}{
		"success": true,
		"agent": map[string]interface{}{
			"id":             createdAgent.ID,
			"name":           createdAgent.Name,
			"description":    createdAgent.Description,
			"max_steps":      createdAgent.MaxSteps,
			"environment_id": createdAgent.EnvironmentID,
		},
		"message": fmt.Sprintf("Agent '%s' created successfully with max_steps=%d in environment_id=%d", name, createdAgent.MaxSteps, createdAgent.EnvironmentID),
	}
	
	// Add tool assignment status to response
	if len(toolNames) > 0 {
		toolAssignment := map[string]interface{}{
			"requested_tools": toolNames,
			"assigned_tools":  assignedTools,
			"assigned_count":  len(assignedTools),
		}
		
		if len(skippedTools) > 0 {
			toolAssignment["skipped_tools"] = skippedTools
			toolAssignment["skipped_count"] = len(skippedTools)
		}
		
		if len(assignedTools) == len(toolNames) {
			toolAssignment["status"] = "success"
		} else if len(assignedTools) > 0 {
			toolAssignment["status"] = "partial"
		} else {
			toolAssignment["status"] = "failed"
		}
		
		response["tool_assignment"] = toolAssignment
		
		// Update message to include tool assignment info
		response["message"] = fmt.Sprintf("Agent '%s' created successfully with max_steps=%d in environment_id=%d. Tools assigned: %d/%d", 
			name, createdAgent.MaxSteps, createdAgent.EnvironmentID, len(assignedTools), len(toolNames))
	}

	resultJSON, _ := json.MarshalIndent(response, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleCallAgent(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	agentIDStr, err := request.RequireString("agent_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Missing 'agent_id' parameter: %v", err)), nil
	}

	agentID, err := strconv.ParseInt(agentIDStr, 10, 64)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Invalid agent_id format: %v", err)), nil
	}

	task, err := request.RequireString("task")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Missing 'task' parameter: %v", err)), nil
	}

	// Execute the agent
	response, err := s.agentService.ExecuteAgent(ctx, agentID, task)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Failed to execute agent: %v", err)), nil
	}

	result := map[string]interface{}{
		"success":   true,
		"agent_id":  agentID,
		"task":      task,
		"response":  response.Content,
	}

	resultJSON, _ := json.MarshalIndent(result, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleDeleteAgent(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	agentIDStr, err := request.RequireString("agent_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Missing 'agent_id' parameter: %v", err)), nil
	}

	agentID, err := strconv.ParseInt(agentIDStr, 10, 64)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Invalid agent_id format: %v", err)), nil
	}

	// Get agent before deletion
	agent, err := s.repos.Agents.GetByID(agentID)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Agent not found: %v", err)), nil
	}

	// Delete the agent
	err = s.repos.Agents.Delete(agentID)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Failed to delete agent: %v", err)), nil
	}

	response := map[string]interface{}{
		"success": true,
		"message": fmt.Sprintf("Agent '%s' deleted successfully", agent.Name),
	}

	resultJSON, _ := json.MarshalIndent(response, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleUpdateAgent(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	agentIDStr, err := request.RequireString("agent_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Missing 'agent_id' parameter: %v", err)), nil
	}

	agentID, err := strconv.ParseInt(agentIDStr, 10, 64)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Invalid agent_id format: %v", err)), nil
	}

	// Get existing agent
	existingAgent, err := s.repos.Agents.GetByID(agentID)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Agent not found: %v", err)), nil
	}

	// Extract optional parameters (use existing values as defaults)
	name := existingAgent.Name
	description := existingAgent.Description
	prompt := existingAgent.Prompt
	maxSteps := existingAgent.MaxSteps
	
	// Override with provided parameters
	if request.Params.Arguments != nil {
		if argsMap, ok := request.Params.Arguments.(map[string]interface{}); ok {
			if newName, ok := argsMap["name"].(string); ok && newName != "" {
				name = newName
			}
			if newDesc, ok := argsMap["description"].(string); ok && newDesc != "" {
				description = newDesc
			}
			if newPrompt, ok := argsMap["prompt"].(string); ok && newPrompt != "" {
				prompt = newPrompt
			}
			if newMaxSteps, ok := argsMap["max_steps"].(float64); ok {
				maxSteps = int64(newMaxSteps)
			}
		}
	}

	// Update the agent
	err = s.repos.Agents.Update(agentID, name, description, prompt, maxSteps, nil, true)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Failed to update agent: %v", err)), nil
	}

	// Handle tool assignment updates
	var toolAssignmentStatus map[string]interface{}
	if request.Params.Arguments != nil {
		if argsMap, ok := request.Params.Arguments.(map[string]interface{}); ok {
			if toolNamesArg, ok := argsMap["tool_names"]; ok {
				var toolNames []string
				if toolNamesArray, ok := toolNamesArg.([]interface{}); ok {
					for _, toolName := range toolNamesArray {
						if str, ok := toolName.(string); ok {
							toolNames = append(toolNames, str)
						}
					}
				}

			if len(toolNames) > 0 {
				// Clear existing tool assignments
				if err := s.repos.AgentTools.Clear(agentID); err != nil {
					return mcp.NewToolResultError(fmt.Sprintf("Failed to clear existing tool assignments: %v", err)), nil
				}

				// Assign new tools
				var assignedTools []string
				var skippedTools []string
				for _, toolName := range toolNames {
					// Find tool by name in the agent's environment
					tool, err := s.repos.MCPTools.FindByNameInEnvironment(existingAgent.EnvironmentID, toolName)
					if err != nil {
						skippedTools = append(skippedTools, fmt.Sprintf("%s (not found in environment)", toolName))
						continue
					}
					
					// Assign tool to agent
					_, err = s.repos.AgentTools.AddAgentTool(agentID, tool.ID)
					if err != nil {
						skippedTools = append(skippedTools, fmt.Sprintf("%s (assignment failed: %v)", toolName, err))
						continue
					}
					
					assignedTools = append(assignedTools, toolName)
				}

				toolAssignmentStatus = map[string]interface{}{
					"requested_tools": toolNames,
					"assigned_tools":  assignedTools,
					"assigned_count":  len(assignedTools),
				}
				
				if len(skippedTools) > 0 {
					toolAssignmentStatus["skipped_tools"] = skippedTools
					toolAssignmentStatus["skipped_count"] = len(skippedTools)
				}
				
				if len(assignedTools) == len(toolNames) {
					toolAssignmentStatus["status"] = "success"
				} else if len(assignedTools) > 0 {
					toolAssignmentStatus["status"] = "partial"
				} else {
					toolAssignmentStatus["status"] = "failed"
				}
			}
		}
	}

	// Get updated agent for response
	updatedAgent, err := s.repos.Agents.GetByID(agentID)
	if err != nil {
		updatedAgent = existingAgent // Fallback to existing agent data
	}

	response := map[string]interface{}{
		"success": true,
		"agent": map[string]interface{}{
			"id":             updatedAgent.ID,
			"name":           updatedAgent.Name,
			"description":    updatedAgent.Description,
			"max_steps":      updatedAgent.MaxSteps,
			"environment_id": updatedAgent.EnvironmentID,
		},
		"message": fmt.Sprintf("Agent '%s' updated successfully", updatedAgent.Name),
	}

	if toolAssignmentStatus != nil {
		response["tool_assignment"] = toolAssignmentStatus
	}

	resultJSON, _ := json.MarshalIndent(response, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleDiscoverTools(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// Get all available tools
	tools, err := s.repos.MCPTools.GetAllWithDetails()
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Failed to discover tools: %v", err)), nil
	}

	response := map[string]interface{}{
		"success": true,
		"tools":   tools,
		"count":   len(tools),
	}

	resultJSON, _ := json.MarshalIndent(response, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleListMCPConfigs(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	// File-based configs: Get all file configs across all environments
	environments, err := s.repos.Environments.List()
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Failed to list environments: %v", err)), nil
	}
	
	var allConfigs []interface{}
	for _, env := range environments {
		fileConfigs, err := s.repos.FileMCPConfigs.ListByEnvironment(env.ID)
		if err != nil {
			continue // Skip environments with no configs
		}
		for _, fc := range fileConfigs {
			allConfigs = append(allConfigs, map[string]interface{}{
				"id":             fc.ID,
				"name":           fc.ConfigName,
				"environment_id": fc.EnvironmentID,
				"path":           fc.TemplatePath,
				"type":           "file",
				"last_loaded":    fc.LastLoadedAt,
			})
		}
	}

	response := map[string]interface{}{
		"success": true,
		"configs": allConfigs,
		"count":   len(allConfigs),
	}

	resultJSON, _ := json.MarshalIndent(response, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleListTools(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	tools, err := s.repos.MCPTools.GetAllWithDetails()
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Failed to list tools: %v", err)), nil
	}

	response := map[string]interface{}{
		"success": true,
		"tools":   tools,
		"count":   len(tools),
	}

	resultJSON, _ := json.MarshalIndent(response, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleListPrompts(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	prompts := []map[string]interface{}{
		{"name": "create_comprehensive_agent", "description": "Guide for creating well-structured AI agents"},
		{"name": "create_logs_analysis_agent", "description": "Guide for AWS logs analysis agents"},
		{"name": "create_devops_monitor_agent", "description": "Guide for DevOps monitoring agents"},
		{"name": "create_security_scan_agent", "description": "Guide for security scanning agents"},
		{"name": "create_data_processing_agent", "description": "Guide for data processing agents"},
	}

	response := map[string]interface{}{
		"success": true,
		"prompts": prompts,
		"count":   len(prompts),
	}

	resultJSON, _ := json.MarshalIndent(response, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleListEnvironments(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	environments, err := s.repos.Environments.List()
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Failed to list environments: %v", err)), nil
	}

	response := map[string]interface{}{
		"success":      true,
		"environments": environments,
		"count":        len(environments),
	}

	resultJSON, _ := json.MarshalIndent(response, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleListAgents(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	agents, err := s.repos.Agents.List()
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Failed to list agents: %v", err)), nil
	}

	response := map[string]interface{}{
		"success": true,
		"agents":  agents,
		"count":   len(agents),
	}

	resultJSON, _ := json.MarshalIndent(response, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

func (s *Server) handleGetAgentDetails(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
	agentIDStr, err := request.RequireString("agent_id")
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Missing 'agent_id' parameter: %v", err)), nil
	}

	agentID, err := strconv.ParseInt(agentIDStr, 10, 64)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Invalid agent_id format: %v", err)), nil
	}

	// Get agent details
	agent, err := s.repos.Agents.GetByID(agentID)
	if err != nil {
		return mcp.NewToolResultError(fmt.Sprintf("Agent not found: %v", err)), nil
	}

	// Get environment
	environment, err := s.repos.Environments.GetByID(agent.EnvironmentID)
	if err != nil {
		environment = &models.Environment{Name: "Unknown"}
	}

	// Get assigned tools
	agentTools, err := s.repos.AgentTools.ListAgentTools(agentID)
	if err != nil {
		agentTools = []*models.AgentToolWithDetails{}
	}

	response := map[string]interface{}{
		"success": true,
		"agent": map[string]interface{}{
			"id":          agent.ID,
			"name":        agent.Name,
			"description": agent.Description,
			"prompt":      agent.Prompt,
			"max_steps":   agent.MaxSteps,
		},
		"environment": map[string]interface{}{
			"id":   environment.ID,
			"name": environment.Name,
		},
		"tools":       agentTools,
		"tools_count": len(agentTools),
	}

	resultJSON, _ := json.MarshalIndent(response, "", "  ")
	return mcp.NewToolResultText(string(resultJSON)), nil
}

