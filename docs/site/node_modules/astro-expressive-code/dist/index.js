// src/index.ts
import remarkExpressiveCode, { createRenderer, getStableObjectHash } from "remark-expressive-code";

// src/vite-plugin.ts
function resolveVirtualModuleId(id) {
  return `\0${id}`;
}
function vitePluginAstroExpressiveCode(contents) {
  const modules = {
    "virtual:astro-expressive-code/scripts": `export const scripts = ${JSON.stringify(contents.scripts)}`,
    "virtual:astro-expressive-code/styles": `export const styles = ${JSON.stringify(contents.styles)}`
  };
  const resolutionMap = Object.fromEntries(Object.keys(modules).map((key) => [resolveVirtualModuleId(key), key]));
  return {
    name: "vite-plugin-astro-expressive-code",
    resolveId(id) {
      if (id in modules)
        return resolveVirtualModuleId(id);
    },
    load(id) {
      const resolution = resolutionMap[id];
      if (resolution)
        return modules[resolution];
    }
  };
}

// src/index.ts
export * from "remark-expressive-code";
function astroExpressiveCode(options = {}) {
  const integration = {
    name: "astro-expressive-code",
    hooks: {
      "astro:config:setup": async (args) => {
        const { config, updateConfig, injectRoute, logger } = args;
        const { emitExternalStylesheet = true, customCreateRenderer, plugins = [], shiki = true, ...rest } = options ?? {};
        const ownPosition = config.integrations.findIndex((integration2) => integration2.name === "astro-expressive-code");
        const mdxPosition = config.integrations.findIndex((integration2) => integration2.name === "@astrojs/mdx");
        if (ownPosition > -1 && mdxPosition > -1 && mdxPosition < ownPosition) {
          throw new Error(
            `Incorrect integration order: To allow code blocks on MDX pages to use
						astro-expressive-code, please move astroExpressiveCode() before mdx()
						in the "integrations" array of your Astro config file.`.replace(/\s+/g, " ")
          );
        }
        const assetsDir = config.build?.assets || "_astro";
        const assetsHrefPrefix = (config?.build?.assetsPrefix || config?.base || "").trim().replace(/\/+$/g, "");
        const hashedStyles = [];
        const hashedScripts = [];
        plugins.push({
          name: "astro-expressive-code",
          hooks: {
            postprocessRenderedBlockGroup: ({ renderData, renderedGroupContents }) => {
              const isFirstGroupInDocument = renderedGroupContents[0]?.codeBlock.parentDocument?.positionInDocument?.groupIndex === 0;
              if (!isFirstGroupInDocument)
                return;
              const extraElements = [];
              hashedStyles.forEach(([hashedRoute]) => {
                extraElements.push({
                  type: "element",
                  tagName: "link",
                  properties: { rel: "stylesheet", href: `${assetsHrefPrefix}${hashedRoute}` },
                  children: []
                });
              });
              hashedScripts.forEach(([hashedRoute]) => {
                extraElements.push({
                  type: "element",
                  tagName: "script",
                  properties: { type: "module", src: `${assetsHrefPrefix}${hashedRoute}` },
                  children: []
                });
              });
              if (!extraElements.length)
                return;
              renderData.groupAst.children.unshift(...extraElements);
            }
          }
        });
        const mergedShikiConfig = shiki === true ? {} : shiki;
        if (mergedShikiConfig && !mergedShikiConfig.langs && config.markdown?.shikiConfig?.langs) {
          mergedShikiConfig.langs = config.markdown.shikiConfig.langs;
        }
        const renderer = await (customCreateRenderer ?? createRenderer)({
          plugins,
          logger,
          shiki: mergedShikiConfig,
          ...rest
        });
        if (emitExternalStylesheet) {
          const combinedStyles = `${renderer.baseStyles}${renderer.themeStyles}`;
          hashedStyles.push(getHashedRouteWithContent(combinedStyles, `/${assetsDir}/ec.{hash}.css`));
          renderer.baseStyles = "";
          renderer.themeStyles = "";
        }
        const uniqueJsModules = [...new Set(renderer.jsModules)];
        renderer.jsModules = [];
        hashedScripts.push(...uniqueJsModules.map((moduleCode) => getHashedRouteWithContent(moduleCode, `/${assetsDir}/ec.{hash}.js`)));
        hashedStyles.forEach(([hashedRoute]) => {
          const entrypoint = new URL("../routes/styles.ts", import.meta.url).href;
          injectRoute({
            pattern: hashedRoute,
            entryPoint: entrypoint,
            // @ts-expect-error: `entrypoint` is the new name since Astro 4
            entrypoint
          });
        });
        hashedScripts.forEach(([hashedRoute]) => {
          const entrypoint = new URL("../routes/scripts.ts", import.meta.url).href;
          injectRoute({
            pattern: hashedRoute,
            entryPoint: entrypoint,
            // @ts-expect-error: `entrypoint` is the new name since Astro 4
            entrypoint
          });
        });
        const remarkExpressiveCodeOptions = {
          customCreateRenderer: () => renderer,
          plugins,
          logger,
          shiki: mergedShikiConfig,
          ...rest
        };
        updateConfig({
          vite: {
            plugins: [
              // Add the Vite plugin that provides all data for the route handler
              vitePluginAstroExpressiveCode({
                styles: hashedStyles,
                scripts: hashedScripts
              })
            ]
          },
          markdown: {
            syntaxHighlight: false,
            remarkPlugins: [[remarkExpressiveCode, remarkExpressiveCodeOptions]]
          }
        });
      }
    }
  };
  return integration;
}
var src_default = astroExpressiveCode;
function getHashedRouteWithContent(content, routeTemplate) {
  const contentHash = getStableObjectHash(content, { hashLength: 5 });
  return [routeTemplate.replace("{hash}", contentHash), content];
}
export {
  astroExpressiveCode,
  src_default as default
};
//# sourceMappingURL=index.js.map