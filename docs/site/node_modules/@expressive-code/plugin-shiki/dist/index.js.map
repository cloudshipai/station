{"version":3,"sources":["../src/index.ts","../src/highlighter.ts"],"sourcesContent":["import { ExpressiveCodeLine, ExpressiveCodePlugin, ExpressiveCodeTheme, InlineStyleAnnotation } from '@expressive-code/core'\nimport { type LanguageInput, ensureLanguageIsLoaded, ensureThemeIsLoaded, getCachedHighlighter } from './highlighter'\nimport { ThemedToken, bundledThemes } from 'shikiji'\n\nexport interface PluginShikiOptions {\n\t/**\n\t * A list of additional languages that should be available for syntax highlighting.\n\t *\n\t * You can pass any of the language input types supported by Shikiji, e.g.:\n\t * - `import('./some-exported-grammar.mjs')`\n\t * - `async () => JSON.parse(await fs.readFile('some-json-grammar.json', 'utf-8'))`\n\t *\n\t * See the [Shikiji documentation](https://github.com/antfu/shikiji) for more information.\n\t *\n\t * Note that you do not need to include languages that are already supported by Shiki.\n\t */\n\tlangs?: LanguageInput[] | undefined\n}\n\n/**\n * A list of all themes bundled with Shiki.\n */\nexport type BundledShikiTheme = Exclude<keyof typeof bundledThemes, 'css-variables'>\n\n/**\n * Loads a theme bundled with Shiki for use with Expressive Code.\n */\nexport async function loadShikiTheme(bundledThemeName: BundledShikiTheme) {\n\tconst shikiTheme = (await bundledThemes[bundledThemeName]()).default\n\treturn new ExpressiveCodeTheme(shikiTheme)\n}\n\n// Workaround: Shikiji exports this as an ambient enum, which throws an error when trying to\n// access its values at runtime, so we're defining it ourselves here as a regular enum.\nenum FontStyle {\n\tNotSet = -1,\n\tNone = 0,\n\tItalic = 1,\n\tBold = 2,\n\tUnderline = 4,\n}\n\nexport function pluginShiki(options: PluginShikiOptions = {}): ExpressiveCodePlugin {\n\tconst { langs } = options\n\treturn {\n\t\tname: 'Shiki',\n\t\thooks: {\n\t\t\tperformSyntaxAnalysis: async ({ codeBlock, styleVariants, config: { logger } }) => {\n\t\t\t\tconst codeLines = codeBlock.getLines()\n\t\t\t\tlet code = codeBlock.code\n\n\t\t\t\t// If the code block uses a terminal language and includes placeholder strings\n\t\t\t\t// in angle brackets (e.g. `<username>`), Shiki will treat the closing `>` as\n\t\t\t\t// a redirect operator and highlight the character before it differently.\n\t\t\t\t// We work around this by replacing the brackets around such placeholder strings\n\t\t\t\t// with different characters that Shiki will not interpret as operators.\n\t\t\t\tif (isTerminalLanguage(codeBlock.language)) {\n\t\t\t\t\tcode = code.replace(/<([^>]*[^>\\s])>/g, 'X$1X')\n\t\t\t\t}\n\n\t\t\t\tlet highlighter\n\t\t\t\ttry {\n\t\t\t\t\thighlighter = await getCachedHighlighter({ langs })\n\t\t\t\t} catch (error) {\n\t\t\t\t\t/* c8 ignore next */\n\t\t\t\t\tconst msg = error instanceof Error ? error.message : (error as string)\n\t\t\t\t\tthrow new Error(`Failed to load syntax highlighter. Please ensure that the configured langs are supported by Shikiji. Received error message: \"${msg}\"`, {\n\t\t\t\t\t\tcause: error,\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\t// Load language if necessary\n\t\t\t\tconst loadedLanguageName = await ensureLanguageIsLoaded(highlighter, codeBlock.language)\n\t\t\t\t// If the requested language wasn't available, log a warning\n\t\t\t\tif (loadedLanguageName !== codeBlock.language) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Found unknown code block language \"${codeBlock.language}\" in ${\n\t\t\t\t\t\t\tcodeBlock.parentDocument?.sourceFilePath ? `document \"${codeBlock.parentDocument?.sourceFilePath}\"` : 'markdown/MDX document'\n\t\t\t\t\t\t}. Using \"${loadedLanguageName}\" instead. You can add custom languages using the \"langs\" config option.`\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tfor (let styleVariantIndex = 0; styleVariantIndex < styleVariants.length; styleVariantIndex++) {\n\t\t\t\t\tconst theme = styleVariants[styleVariantIndex].theme\n\n\t\t\t\t\t// Load theme if necessary\n\t\t\t\t\tconst loadedThemeName = await ensureThemeIsLoaded(highlighter, theme)\n\n\t\t\t\t\t// Run highlighter (without explanations to improve performance)\n\t\t\t\t\tconst tokenLines = highlighter.codeToThemedTokens(code, {\n\t\t\t\t\t\tlang: loadedLanguageName,\n\t\t\t\t\t\ttheme: loadedThemeName,\n\t\t\t\t\t\tincludeExplanation: false,\n\t\t\t\t\t})\n\n\t\t\t\t\ttokenLines.forEach((line, lineIndex) => {\n\t\t\t\t\t\tif (codeBlock.language === 'ansi' && styleVariantIndex === 0) removeAnsiSequencesFromCodeLine(codeLines[lineIndex], line)\n\n\t\t\t\t\t\tlet charIndex = 0\n\t\t\t\t\t\tline.forEach((token) => {\n\t\t\t\t\t\t\tconst tokenLength = token.content.length\n\t\t\t\t\t\t\tconst tokenEndIndex = charIndex + tokenLength\n\t\t\t\t\t\t\tconst fontStyle = token.fontStyle || FontStyle.None\n\t\t\t\t\t\t\tcodeLines[lineIndex].addAnnotation(\n\t\t\t\t\t\t\t\tnew InlineStyleAnnotation({\n\t\t\t\t\t\t\t\t\tstyleVariantIndex,\n\t\t\t\t\t\t\t\t\tcolor: token.color || theme.fg,\n\t\t\t\t\t\t\t\t\titalic: ((fontStyle & FontStyle.Italic) as FontStyle) === FontStyle.Italic,\n\t\t\t\t\t\t\t\t\tbold: ((fontStyle & FontStyle.Bold) as FontStyle) === FontStyle.Bold,\n\t\t\t\t\t\t\t\t\tunderline: ((fontStyle & FontStyle.Underline) as FontStyle) === FontStyle.Underline,\n\t\t\t\t\t\t\t\t\tinlineRange: {\n\t\t\t\t\t\t\t\t\t\tcolumnStart: charIndex,\n\t\t\t\t\t\t\t\t\t\tcolumnEnd: tokenEndIndex,\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\trenderPhase: 'earliest',\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tcharIndex = tokenEndIndex\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunction isTerminalLanguage(language: string) {\n\treturn ['shellscript', 'shell', 'bash', 'sh', 'zsh'].includes(language)\n}\n\n/**\n * Removes ANSI sequences processed by Shiki from the provided codeline\n */\nfunction removeAnsiSequencesFromCodeLine(codeLine: ExpressiveCodeLine, lineTokens: ThemedToken[]): void {\n\t// The provided tokens from Shiki will already be stripped for control characters\n\tconst newLine = lineTokens.map((token) => token.content).join('')\n\t// Removing sequences by ranges instead of whole line to avoid breaking any existing annotations\n\tconst rangesToRemove = getRemovedRanges(codeLine.text, newLine)\n\tfor (let index = rangesToRemove.length - 1; index >= 0; index--) {\n\t\tconst [start, end] = rangesToRemove[index]\n\t\tcodeLine.editText(start, end, '')\n\t}\n}\n\n/**\n * Compares a given `original` string to its `edited` version, assuming that the only kind of edits\n * allowed between them is the removal of column ranges from the original string.\n *\n * Returns an array of column ranges that were removed from the original string.\n */\nfunction getRemovedRanges(original: string, edited: string): [start: number, end: number][] {\n\tconst ranges: [start: number, ends: number][] = []\n\tlet from = -1\n\tlet orgIdx = 0\n\tlet edtIdx = 0\n\n\twhile (orgIdx < original.length && edtIdx < edited.length) {\n\t\tif (original[orgIdx] !== edited[edtIdx]) {\n\t\t\tif (from === -1) from = orgIdx\n\t\t\torgIdx++\n\t\t} else {\n\t\t\tif (from > -1) {\n\t\t\t\tranges.push([from, orgIdx])\n\t\t\t\tfrom = -1\n\t\t\t}\n\t\t\torgIdx++\n\t\t\tedtIdx++\n\t\t}\n\t}\n\n\tif (edtIdx < edited.length) throw new Error(`Edited string contains characters not present in original (${JSON.stringify({ original, edited })})`)\n\n\tif (orgIdx < original.length) ranges.push([orgIdx, original.length])\n\n\treturn ranges\n}\n","import { Highlighter, ThemeRegistration, getHighlighter, isSpecialLang, bundledLanguages, BuiltinLanguage } from 'shikiji'\nimport type { LanguageInput as ShikijiLanguageInput, LanguageRegistration as ShikijiLanguageRegistration, MaybeGetter, MaybeArray } from 'shikiji'\nimport { ExpressiveCodeTheme, getStableObjectHash } from '@expressive-code/core'\n\n// Unfortunately, the types exported by `vscode-textmate` that are used by Shikiji\n// don't match the actual grammar requirements & parsing logic in some aspects.\n// The types defined here attempt to reduce the amount of incorrect type errors\n// that would otherwise when importing and adding external grammars.\ntype Optional<T, K extends keyof T> = Omit<T, K> & Pick<Partial<T>, K>\ntype IRawRepository = Optional<ShikijiLanguageRegistration['repository'], '$self' | '$base'>\nexport interface LanguageRegistration extends Omit<ShikijiLanguageRegistration, 'repository'> {\n\trepository?: IRawRepository | undefined\n}\nexport type LanguageInput = MaybeGetter<MaybeArray<LanguageRegistration>>\n\nconst highlighterPromiseByConfig = new Map<string, Promise<Highlighter>>()\nconst promisesByHighlighter = new WeakMap<Highlighter, Map<string, Promise<void>>>()\nconst themeCacheKeys = new WeakMap<ExpressiveCodeTheme, string>()\n\n/**\n * Gets a cached Shiki highlighter instance for the given configuration.\n */\nexport async function getCachedHighlighter(config: { langs?: LanguageInput[] | undefined } = {}): Promise<Highlighter> {\n\tconst configCacheKey = getStableObjectHash(config)\n\tlet highlighterPromise = highlighterPromiseByConfig.get(configCacheKey)\n\tif (highlighterPromise === undefined) {\n\t\thighlighterPromise = getHighlighter({\n\t\t\t...(config.langs ? { langs: config.langs as ShikijiLanguageInput[] } : {}),\n\t\t})\n\t\thighlighterPromiseByConfig.set(configCacheKey, highlighterPromise)\n\t}\n\treturn highlighterPromise\n}\n\nexport async function ensureThemeIsLoaded(highlighter: Highlighter, theme: ExpressiveCodeTheme) {\n\t// Unfortunately, Shiki caches themes by name, so we need to ensure that the theme name changes\n\t// whenever the theme contents change by appending a content hash\n\tconst existingCacheKey = themeCacheKeys.get(theme)\n\tconst cacheKey = existingCacheKey ?? `${theme.name}-${getStableObjectHash({ bg: theme.bg, fg: theme.fg, settings: theme.settings })}`\n\tif (!existingCacheKey) themeCacheKeys.set(theme, cacheKey)\n\n\t// Only load the theme if it hasn't been loaded yet\n\tif (!highlighter.getLoadedThemes().includes(cacheKey)) {\n\t\t// Load the theme or wait for an existing load task to finish\n\t\tawait memoizeHighlighterTask(highlighter, `loadTheme:${cacheKey}`, () => {\n\t\t\tconst themeUsingCacheKey = { ...theme, name: cacheKey, settings: theme.settings as ThemeRegistration['settings'] }\n\t\t\treturn highlighter.loadTheme(themeUsingCacheKey)\n\t\t})\n\t}\n\treturn cacheKey\n}\n\nexport async function ensureLanguageIsLoaded(highlighter: Highlighter, language: string) {\n\tconst loadedLanguages = new Set(highlighter.getLoadedLanguages())\n\tif (!loadedLanguages.has(language) && !isSpecialLang(language)) {\n\t\t// If the language is not available, fall back to \"txt\"\n\t\tif (!Object.keys(bundledLanguages).includes(language)) {\n\t\t\tlanguage = 'txt'\n\t\t}\n\n\t\t// Load the language or wait for an existing load task to finish\n\t\tawait memoizeHighlighterTask(highlighter, `loadLanguage:${language}`, () => highlighter.loadLanguage(language as BuiltinLanguage))\n\t}\n\treturn language\n}\n\n/**\n * Memoizes a task by ID for a given highlighter instance.\n *\n * This is necessary because SSGs can process multiple pages in parallel and we don't want to\n * start the same async task multiple times, but instead return the same promise for all calls\n * to improve performance and reduce memory usage.\n */\nfunction memoizeHighlighterTask(highlighter: Highlighter, taskId: string, taskFn: () => Promise<void>) {\n\tlet promises = promisesByHighlighter.get(highlighter)\n\tif (!promises) {\n\t\tpromises = new Map()\n\t\tpromisesByHighlighter.set(highlighter, promises)\n\t}\n\tlet promise = promises.get(taskId)\n\tif (promise === undefined) {\n\t\tpromise = taskFn()\n\t\tpromises.set(taskId, promise)\n\t}\n\treturn promise\n}\n"],"mappings":"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","names":["ExpressiveCodeTheme","ExpressiveCodeTheme"]}