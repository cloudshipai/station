// src/internal/type-checks.ts
function isNumber(input) {
  return typeof input === "number" && !isNaN(input);
}
function isString(input) {
  return typeof input === "string";
}
function isBoolean(input) {
  return typeof input === "boolean";
}
function isHastNode(node) {
  return node && node.type && typeof node.type === "string";
}
function isHastElement(node) {
  return isHastNode(node) && node.type === "element";
}
function isHastParent(node) {
  return isHastNode(node) && (node.type === "element" || node.type === "root");
}
function newTypeError(expectedTypeDescription, actualValue, fieldName) {
  return new Error(`${fieldName ? `Invalid ${fieldName} value: ` : ""}Expected a valid ${expectedTypeDescription}, but got ${JSON.stringify(actualValue)}`);
}

// src/common/annotation.ts
import { h } from "hastscript";

// src/helpers/ast.ts
function getClassNames(node) {
  const stringOrArr = node.properties?.className;
  if (!stringOrArr || stringOrArr === true)
    return [];
  if (Array.isArray(stringOrArr))
    return stringOrArr.map((className) => className.toString());
  return stringOrArr.toString().split(" ");
}
function setProperty(node, propertyName, value) {
  const properties = node.properties || {};
  node.properties = properties;
  properties[propertyName] = value;
}
function addClassName(node, className) {
  const classNames = getClassNames(node);
  if (classNames.indexOf(className) === -1)
    classNames.push(className);
  setProperty(node, "className", classNames);
}

// src/common/annotation.ts
var AnnotationRenderPhaseOrder = ["earliest", "earlier", "normal", "later", "latest"];
function annotationSortFn(a, b) {
  const indexA = AnnotationRenderPhaseOrder.indexOf(a.renderPhase || "normal");
  const indexB = AnnotationRenderPhaseOrder.indexOf(b.renderPhase || "normal");
  return indexA - indexB;
}
var ExpressiveCodeAnnotation = class {
  constructor({ inlineRange, renderPhase }) {
    if (inlineRange)
      validateExpressiveCodeInlineRange(inlineRange);
    this.inlineRange = inlineRange;
    this.renderPhase = renderPhase ?? "normal";
  }
  /**
   * An optional range of columns within the line that this annotation applies to.
   * If not provided, the annotation will apply to the entire line.
   */
  inlineRange;
  /**
   * Determines the phase in which this annotation should be rendered.
   * Rendering is done in phases, from `earliest` to `latest`.
   * Annotations with the same phase are rendered in the order they were added.
   *
   * The earlier an annotation is rendered, the more likely it is to be split, modified
   * or wrapped by later annotations. Syntax highlighting is rendered in the `earliest` phase
   * to allow other annotations to wrap and modify the highlighted code.
   *
   * The default phase is `normal`.
   */
  renderPhase;
};
var InlineStyleAnnotation = class extends ExpressiveCodeAnnotation {
  color;
  italic;
  bold;
  underline;
  styleVariantIndex;
  constructor({ color, italic = false, bold = false, underline = false, styleVariantIndex, ...baseOptions }) {
    super(baseOptions);
    this.color = color;
    this.italic = italic;
    this.bold = bold;
    this.underline = underline;
    this.styleVariantIndex = styleVariantIndex;
  }
  render({ nodesToTransform, styleVariants }) {
    const newStyles = /* @__PURE__ */ new Map();
    const addStylesForVariantIndex = (variantIndex) => {
      const varPrefix = `--${variantIndex}`;
      if (this.color)
        newStyles.set(varPrefix, this.color);
      if (this.italic)
        newStyles.set(`${varPrefix}fs`, "italic");
      if (this.bold)
        newStyles.set(`${varPrefix}fw`, "bold");
      if (this.underline)
        newStyles.set(`${varPrefix}td`, "underline");
    };
    const variantIndices = this.styleVariantIndex !== void 0 ? [this.styleVariantIndex] : styleVariants.map((_, i) => i);
    variantIndices.forEach(addStylesForVariantIndex);
    if (newStyles.size === 0)
      return nodesToTransform;
    const buildStyleString = (styles) => {
      return [...styles].map(([key, value]) => `${key}:${value}`).join(";");
    };
    const isInlineStyleNode = (node) => node.tagName === "span" && // Our inline style nodes have no class names
    !getClassNames(node).length && // Our inline style nodes contain CSS variable declarations
    node.properties?.style?.toString().startsWith("--");
    const modifyExistingStyles = (node, remove = false) => {
      const existingStyles = (node.properties?.style?.toString() || "").split(";").map((style) => {
        const declParts = style.split(":");
        return [declParts[0], declParts.slice(1).join(":")];
      });
      const modifiedStylesMap = new Map(existingStyles);
      newStyles.forEach((value, key) => {
        if (remove) {
          modifiedStylesMap.delete(key);
        } else {
          modifiedStylesMap.set(key, value);
        }
      });
      const modifiedStyles = buildStyleString(modifiedStylesMap);
      if (modifiedStyles) {
        setProperty(node, "style", modifiedStyles);
      } else if (node.properties?.style) {
        delete node.properties.style;
      }
      return modifiedStyles;
    };
    return nodesToTransform.map((node) => {
      if (node.type === "element" && isInlineStyleNode(node)) {
        modifyExistingStyles(node);
        return node;
      }
      const removeNestedConflictingStyles = (node2) => {
        for (let childIdx = node2.children?.length - 1; childIdx >= 0; childIdx--) {
          const child = node2.children[childIdx];
          if (child.type === "element") {
            if (isInlineStyleNode(child)) {
              if (!modifyExistingStyles(child, true)) {
                node2.children.splice(childIdx, 1, ...child.children);
              }
            }
            removeNestedConflictingStyles(child);
          }
        }
      };
      removeNestedConflictingStyles(node);
      const transformedNode = h("span", { style: buildStyleString(newStyles) }, node);
      return transformedNode;
    });
  }
};
function validateExpressiveCodeInlineRange(inlineRange) {
  if (!isNumber(inlineRange.columnStart) || !isNumber(inlineRange.columnEnd))
    throw newTypeError("ExpressiveCodeInlineRange", inlineRange);
}
function validateExpressiveCodeAnnotation(annotation) {
  try {
    if (!(annotation instanceof ExpressiveCodeAnnotation))
      throw "Not an ExpressiveCodeAnnotation instance";
    if (annotation.inlineRange)
      validateExpressiveCodeInlineRange(annotation.inlineRange);
  } catch (error) {
    throw newTypeError("instance of ExpressiveCodeAnnotation", annotation);
  }
}

// src/internal/render-block.ts
import { h as h3 } from "hastscript";

// src/common/plugin-hooks.ts
async function runHooks(key, plugins, runner) {
  for (const plugin of plugins) {
    const hookFn = plugin.hooks?.[key];
    if (!hookFn)
      continue;
    try {
      await runner({ hookName: key, hookFn, plugin });
    } catch (error) {
      const msg = error instanceof Error ? error.message : error;
      throw new Error(`Plugin "${plugin.name}" caused an error in its "${key}" hook. Error message: ${msg}`, { cause: error });
    }
  }
}

// src/internal/render-line.ts
import { h as h2 } from "hastscript";

// src/common/style-settings.ts
var cssVarReplacements = /* @__PURE__ */ new Map([
  ["background", "bg"],
  ["foreground", "fg"],
  ["color", "col"],
  ["border", "brd"],
  ["padding", "pad"],
  ["margin", "marg"],
  ["radius", "rad"],
  ["opacity", "opa"],
  ["width", "wd"],
  ["height", "ht"],
  ["weight", "wg"],
  ["block", "blk"],
  ["inline", "inl"],
  ["bottom", "btm"],
  ["value", "val"],
  ["active", "act"],
  ["inactive", "inact"],
  ["highlight", "hl"],
  ["selection", "sel"],
  ["indicator", "ind"],
  ["shadow", "shd"],
  ["family", "fml"],
  ["transform", "trf"],
  ["decoration", "dec"],
  ["button", "btn"],
  ["editor", "ed"],
  ["terminal", "trm"],
  ["scrollbar", "sb"],
  ["toolbar", "tb"],
  ["titlebar", "ttb"],
  ["textMarkers", "tm"],
  ["frames", "frm"]
]);
function getCssVarName(styleSetting) {
  let varName = styleSetting.replace(/\./g, "-");
  const capitalize = (word) => word[0].toUpperCase() + word.slice(1);
  cssVarReplacements.forEach((replacement, term) => {
    const termRegExp = new RegExp(
      [
        // The lowercase term,
        // preceded by a non-lowercase character or the beginning of the string,
        // and followed by a non-lowercase character or the end of the string
        `(?<=[^a-z]|^)${term}(?=[^a-z]|$)`,
        // The capitalized term,
        // preceded by a lowercase character or the beginning of the string,
        // and followed by a non-lowercase character or the end of the string
        `(?<=[a-z]|^)${capitalize(term)}(?=[^a-z]|$)`
      ].join("|"),
      "g"
    );
    varName = varName.replace(termRegExp, (match) => match === term ? replacement : capitalize(replacement));
  });
  return `--ec-${varName}`;
}
var codeLineClass = "ec-line";

// src/internal/render-line.ts
function splitLineAtAnnotationBoundaries(line) {
  const textParts = [];
  const partIndicesByAnnotation = /* @__PURE__ */ new Map();
  const fullText = line.text;
  const annotations = line.getAnnotations();
  const annotationBoundaries = [
    ...new Set(
      annotations.flatMap(({ inlineRange }) => {
        if (!inlineRange)
          return [];
        return [inlineRange.columnStart, inlineRange.columnEnd];
      })
    )
  ].sort((a, b) => a - b);
  let lastColumn = 0;
  annotationBoundaries.forEach((column) => {
    if (column === lastColumn)
      return;
    textParts.push(fullText.slice(lastColumn, column));
    lastColumn = column;
  });
  if (lastColumn < fullText.length)
    textParts.push(fullText.slice(lastColumn));
  annotations.forEach((annotation) => {
    if (!annotation.inlineRange)
      return;
    const { columnStart, columnEnd } = annotation.inlineRange;
    const partIndices = [];
    let partStart = 0;
    textParts.forEach((part, partIndex) => {
      const partEnd = partStart + part.length;
      if (partStart >= columnStart && partEnd <= columnEnd) {
        partIndices.push(partIndex);
      }
      partStart = partEnd;
    });
    partIndicesByAnnotation.set(annotation, partIndices);
  });
  return {
    textParts,
    partIndicesByAnnotation
  };
}
function renderLineToAst({ line, ...restContext }) {
  const { textParts, partIndicesByAnnotation } = splitLineAtAnnotationBoundaries(line);
  const partNodes = textParts.map((textPart) => h2(null, [textPart]));
  const annotations = [...line.getAnnotations()].sort(annotationSortFn);
  annotations.forEach((annotation, annotationIndex) => {
    if (!annotation.inlineRange)
      return;
    const partIndices = partIndicesByAnnotation.get(annotation);
    if (!partIndices)
      throw new Error(`Failed to find inline annotation in part indices: ${JSON.stringify(annotation)}`);
    if (partIndices.length > 1) {
      const isPartiallyContainedInLaterAnnotations = annotations.slice(annotationIndex + 1).some((laterAnnotation) => {
        if (!laterAnnotation.inlineRange)
          return false;
        const laterPartIndices = partIndicesByAnnotation.get(laterAnnotation);
        if (!laterPartIndices)
          return false;
        const intersectingParts = laterPartIndices.filter((partIndex) => partIndices.includes(partIndex));
        const isPartiallyContained = intersectingParts.length > 0 && intersectingParts.length < partIndices.length;
        return isPartiallyContained;
      });
      if (!isPartiallyContainedInLaterAnnotations) {
        const mergedNode = h2(
          null,
          partIndices.map((partIndex) => partNodes[partIndex])
        );
        partNodes.splice(partIndices[0], partIndices.length, mergedNode);
        const indicesToRemove = partIndices.length - 1;
        const firstPartIndex = partIndices[0];
        const lastPartIndex = partIndices[partIndices.length - 1];
        partIndicesByAnnotation.forEach((partIndicesToCheck) => {
          let anyChanges = false;
          const updatedIndices = partIndicesToCheck.map((partIndex) => {
            if (partIndex <= firstPartIndex)
              return partIndex;
            anyChanges = true;
            if (partIndex > lastPartIndex)
              return partIndex - indicesToRemove;
            return NaN;
          }).filter((partIndex) => !isNaN(partIndex));
          if (anyChanges) {
            partIndicesToCheck.splice(0, partIndicesToCheck.length, ...updatedIndices);
          }
        });
      }
    }
    const renderInput = partIndices.map((partIndex) => partNodes[partIndex]);
    const renderOutput = annotation.render({ nodesToTransform: [...renderInput], line, ...restContext });
    validateAnnotationRenderOutput(renderOutput, renderInput.length);
    partIndices.forEach((partIndex, index) => {
      partNodes[partIndex] = renderOutput[index];
    });
  });
  if (partNodes.length === 0)
    partNodes.push(h2(null, "\n"));
  let lineNode = h2(`div.${codeLineClass}`, partNodes);
  annotations.forEach((annotation) => {
    if (annotation.inlineRange)
      return;
    const renderOutput = annotation.render({ nodesToTransform: [lineNode], line, ...restContext });
    validateAnnotationRenderOutput(renderOutput, 1);
    lineNode = renderOutput[0];
  });
  return lineNode;
}
function validateAnnotationRenderOutput(nodes, expectedLength) {
  if (!Array.isArray(nodes) || nodes.length !== expectedLength)
    throw new Error(`Expected annotation render function to return an array of ${expectedLength} node(s), but got ${JSON.stringify(nodes)}.`);
  nodes.forEach((node, nodeIndex) => {
    if (!node || !node.type)
      throw new Error(`Annotation render function returned an invalid node at index ${nodeIndex}: ${JSON.stringify(node)}`);
  });
}

// src/internal/render-block.ts
async function renderBlock({
  codeBlock,
  groupContents,
  locale,
  config,
  plugins,
  cssVar,
  cssVarName,
  styleVariants
}) {
  const state = {
    canEditAnnotations: true,
    canEditCode: true,
    canEditMetadata: true
  };
  codeBlock.state = state;
  const blockStyles = [];
  const baseContext = {
    codeBlock,
    groupContents,
    locale,
    config,
    cssVar,
    cssVarName,
    styleVariants
  };
  const runBeforeRenderingHooks = async (key) => {
    await runHooks(key, plugins, async ({ hookFn, plugin }) => {
      await hookFn({
        ...baseContext,
        addStyles: (styles) => blockStyles.push({ pluginName: plugin.name, styles })
      });
    });
  };
  state.canEditCode = false;
  await runBeforeRenderingHooks("preprocessMetadata");
  state.canEditCode = true;
  await runBeforeRenderingHooks("preprocessCode");
  await runBeforeRenderingHooks("performSyntaxAnalysis");
  await runBeforeRenderingHooks("postprocessAnalyzedCode");
  state.canEditCode = false;
  await runBeforeRenderingHooks("annotateCode");
  await runBeforeRenderingHooks("postprocessAnnotations");
  state.canEditMetadata = false;
  state.canEditAnnotations = false;
  const lines = codeBlock.getLines();
  const renderedAstLines = [];
  for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
    const line = lines[lineIndex];
    const lineRenderData = {
      lineAst: renderLineToAst({ line, ...baseContext })
    };
    await runHooks("postprocessRenderedLine", plugins, async ({ hookFn, plugin }) => {
      await hookFn({
        ...baseContext,
        addStyles: (styles) => blockStyles.push({ pluginName: plugin.name, styles }),
        line,
        lineIndex,
        renderData: lineRenderData
      });
      if (!isHastElement(lineRenderData.lineAst)) {
        throw newTypeError("hast Element", lineRenderData.lineAst, "lineAst");
      }
    });
    renderedAstLines.push(lineRenderData.lineAst);
  }
  const blockRenderData = {
    blockAst: buildCodeBlockAstFromRenderedLines(renderedAstLines)
  };
  await runHooks("postprocessRenderedBlock", plugins, async ({ hookFn, plugin }) => {
    await hookFn({
      ...baseContext,
      addStyles: (styles) => blockStyles.push({ pluginName: plugin.name, styles }),
      renderData: blockRenderData
    });
    if (!isHastParent(blockRenderData.blockAst)) {
      throw newTypeError("hast Parent", blockRenderData.blockAst, "blockAst");
    }
  });
  return {
    renderedBlockAst: blockRenderData.blockAst,
    blockStyles
  };
}
function buildCodeBlockAstFromRenderedLines(renderedLines) {
  return h3("pre", { tabindex: 0 }, h3("code", renderedLines));
}
function validateExpressiveCodeProcessingState(state) {
  const isValid = state && isBoolean(state.canEditCode) && isBoolean(state.canEditMetadata) && isBoolean(state.canEditAnnotations);
  if (!isValid)
    throw newTypeError("ExpressiveCodeProcessingState", state);
}

// src/internal/ranges.ts
function getAbsoluteRange({
  start,
  end,
  rangeMax
}) {
  start = Math.min(start ?? 0, rangeMax);
  end = Math.min(end ?? rangeMax, rangeMax);
  if (start < 0)
    start = Math.max(start + rangeMax, 0);
  if (end < 0)
    end = Math.max(end + rangeMax, 0);
  return [start, end];
}

// src/common/line.ts
var ExpressiveCodeLine = class {
  constructor(text) {
    if (typeof text !== "string")
      throw new Error(`Expected code line text to be a string, but got ${JSON.stringify(text)}.`);
    this.#text = text;
  }
  #text;
  get text() {
    return this.#text;
  }
  #parent;
  get parent() {
    return this.#parent;
  }
  set parent(value) {
    if (!(value instanceof ExpressiveCodeBlock))
      throw new Error("When setting the parent of a code line, you must specify a valid code block instance.");
    if (this.#parent) {
      if (this.#parent === value)
        return;
      throw new Error(`You cannot change the parent of a code line after it has been added to a code block.`);
    }
    this.#parent = value;
  }
  #annotations = [];
  getAnnotations() {
    const matchingAnnotations = this.#annotations.filter((annotation) => !!annotation);
    return Object.freeze(matchingAnnotations);
  }
  addAnnotation(annotation) {
    validateExpressiveCodeAnnotation(annotation);
    if (this.#parent?.state?.canEditAnnotations === false)
      throw new Error("Cannot edit code line annotations in the current state.");
    this.#annotations.push(annotation);
  }
  deleteAnnotation(annotation) {
    validateExpressiveCodeAnnotation(annotation);
    if (this.#parent?.state?.canEditAnnotations === false)
      throw new Error("Cannot edit code line annotations in the current state.");
    const index = this.#annotations.indexOf(annotation);
    if (index === -1)
      throw new Error(
        `Failed to delete annotation as it was not found (name=${JSON.stringify(annotation.constructor.name)}, inlineRange=${JSON.stringify(annotation.inlineRange)})`
      );
    this.#annotations.splice(index, 1);
  }
  editText(columnStart, columnEnd, newText) {
    if (columnStart !== void 0 && !isNumber(columnStart))
      throw newTypeError("number", columnStart);
    if (columnEnd !== void 0 && !isNumber(columnEnd))
      throw newTypeError("number", columnEnd);
    if (!isString(newText))
      throw newTypeError("string", newText);
    if (this.#parent?.state?.canEditCode === false)
      throw new Error("Cannot edit code line text in the current state.");
    const [editStart, editEnd] = getAbsoluteRange({ start: columnStart, end: columnEnd, rangeMax: this.#text.length });
    const editDelta = newText.length - (editEnd - editStart);
    for (let index = this.#annotations.length - 1; index >= 0; index--) {
      const annotation = this.#annotations[index];
      if (!annotation.inlineRange)
        continue;
      const { columnStart: annotationStart, columnEnd: annotationEnd } = annotation.inlineRange;
      if (annotationEnd < editStart)
        continue;
      if (annotationStart > editEnd) {
        annotation.inlineRange.columnStart += editDelta;
        annotation.inlineRange.columnEnd += editDelta;
        continue;
      }
      if (editStart >= annotationStart && editEnd <= annotationEnd) {
        annotation.inlineRange.columnEnd += editDelta;
        continue;
      }
      if (editStart <= annotationStart && editEnd >= annotationEnd) {
        this.#annotations.splice(index, 1);
        continue;
      }
      if (editStart > annotationStart) {
        annotation.inlineRange.columnEnd = editStart;
      } else {
        annotation.inlineRange.columnStart = editEnd + editDelta;
        annotation.inlineRange.columnEnd += editDelta;
      }
    }
    this.#text = this.text.slice(0, editStart) + newText + this.text.slice(editEnd);
    return this.text;
  }
};

// src/common/block.ts
var ExpressiveCodeBlock = class {
  constructor(options) {
    const { code, language, meta = "", locale, parentDocument } = options;
    if (!isString(code) || !isString(language) || !isString(meta))
      throw newTypeError("object of type ExpressiveCodeBlockOptions", options);
    this.#lines = [];
    this.#language = language;
    this.#meta = meta;
    this.#locale = locale;
    this.#parentDocument = parentDocument;
    const lines = code.split(/\r?\n/).map((line) => line.trimEnd());
    while (lines.length && !lines[0].length)
      lines.shift();
    while (lines.length && !lines[lines.length - 1].length)
      lines.pop();
    if (lines.length)
      this.insertLines(0, lines);
  }
  /**
   * This field exists to ensure that only actual class instances are accepted
   * as the type `ExpressiveCodeBlock` by TypeScript. Without this workaround,
   * plain objects with the same structure would be accepted, but fail at runtime.
   */
  _requireInstance = Symbol("ExpressiveCodeBlock");
  #lines;
  #language;
  #meta;
  #locale;
  #parentDocument;
  #state;
  /**
   * Provides read-only access to the code block’s plaintext contents.
   */
  get code() {
    return this.#lines.map((line) => line.text).join("\n");
  }
  get language() {
    return this.#language;
  }
  /**
   * Allows getting and setting the code block’s language.
   *
   * Setting this property may throw an error if not allowed in the current {@link state}.
   */
  set language(value) {
    if (this.#state?.canEditMetadata === false)
      throw new Error('Cannot edit code block property "language" in the current state.');
    this.#language = value;
  }
  get meta() {
    return this.#meta;
  }
  /**
   * Allows getting or setting the code block’s meta string. In markdown or MDX documents,
   * this is the part of the code block’s opening fence that comes after the language name.
   *
   * Setting this property may throw an error if not allowed in the current {@link state}.
   */
  set meta(value) {
    if (this.#state?.canEditMetadata === false)
      throw new Error('Cannot edit code block property "meta" in the current state.');
    this.#meta = value;
  }
  /**
   * Allows getting the code block's locale (e.g. `en-US` or `de-DE`). It is used by plugins
   * to display localized strings depending on the language of the containing page.
   *
   * Integrations like `remark-expressive-code` support multi-language sites by allowing you
   * to provide custom logic to determine a block's locale (e.g. based on its parent document).
   *
   * If no locale is defined here, `ExpressiveCodeEngine` will render the code block
   * using the `defaultLocale` provided in its configuration.
   */
  get locale() {
    return this.#locale;
  }
  /**
   * Provides read-only access to optional data about the parent document
   * the code block is located in.
   *
   * Integrations like `remark-expressive-code` can provide this information based on
   * the source document being processed. There may be cases where no document is available,
   * e.g. when the code block was created dynamically.
   */
  get parentDocument() {
    return this.#parentDocument;
  }
  /**
   * Provides read-only access to the code block’s processing state.
   *
   * The processing state controls which properties of the code block can be modified.
   * The engine updates it automatically during rendering.
   */
  get state() {
    if (this.#state) {
      const result = { ...this.#state };
      Object.freeze(result);
      return result;
    }
  }
  /**
   * @internal
   */
  set state(value) {
    validateExpressiveCodeProcessingState(value);
    if (this.#state) {
      if (this.#state === value)
        return;
      throw new Error(`You cannot change the state object of a code block after assigning it once.`);
    }
    this.#state = value;
  }
  /**
   * Returns the line at the given index, or `undefined` if the index is out of range.
   */
  getLine(index) {
    if (!isNumber(index) || index < 0)
      throw new Error("Line index must be a non-negative number.");
    return this.getLines(index, index + 1)[0];
  }
  /**
   * Returns a readonly array of lines starting at the given index and ending before
   * the given index (exclusive). The indices support the same syntax as JavaScript’s
   * `Array.slice` method.
   */
  getLines(startIndex, endIndex) {
    return Object.freeze(this.#lines.slice(startIndex, endIndex));
  }
  /**
   * Deletes the line at the given index.
   *
   * May throw an error if not allowed in the current {@link state}.
   */
  deleteLine(index) {
    this.deleteLines([index]);
  }
  /**
   * Deletes the lines at the given indices.
   *
   * This function automatically sorts the indices in descending order before deleting the lines,
   * so you do not need to worry about indices shifting after deleting a line.
   *
   * May throw an error if not allowed in the current {@link state}.
   */
  deleteLines(indices) {
    if (!Array.isArray(indices) || indices.length === 0 || indices.some((index) => !isNumber(index) || index < 0))
      throw newTypeError("non-empty non-negative number[]", indices);
    if (this.#state?.canEditCode === false)
      throw new Error("Cannot delete code block lines in the current state.");
    const sorted = [...indices].sort((a, b) => b - a);
    let lastIndex;
    sorted.forEach((index) => {
      if (lastIndex === index)
        throw new Error(`A batch of lines to delete cannot contain the same index twice. Given indices: ${JSON.stringify(indices)}`);
      lastIndex = index;
      const isValidIndex = index >= 0 && index < this.#lines.length;
      if (!isValidIndex)
        throw new Error(`Cannot delete invalid index ${JSON.stringify(index)} from line array (length=${this.#lines.length}). Given indices: ${JSON.stringify(indices)}`);
      this.#lines.splice(index, 1);
    });
  }
  /**
   * Inserts a new line at the given index.
   *
   * May throw an error if not allowed in the current {@link state}.
   */
  insertLine(index, textLine) {
    return this.insertLines(index, [textLine])[0];
  }
  /**
   * Inserts multiple new lines at the given index.
   *
   * May throw an error if not allowed in the current {@link state}.
   */
  insertLines(index, textLines) {
    if (!isNumber(index) || index < 0)
      throw newTypeError("non-negative number", index);
    if (!Array.isArray(textLines) || textLines.length === 0 || textLines.some((textLine) => !isString(textLine)))
      throw newTypeError("non-empty string[]", textLines);
    if (this.#state?.canEditCode === false)
      throw new Error("Cannot insert code block lines in the current state.");
    const isValidIndex = index >= 0 && index <= this.#lines.length;
    if (!isValidIndex)
      throw new Error(`Cannot insert at invalid index ${JSON.stringify(index)} into line array (length=${this.#lines.length}).`);
    const lineInstances = textLines.map((text) => {
      const line = new ExpressiveCodeLine(text);
      line.parent = this;
      return line;
    });
    this.#lines.splice(index, 0, ...lineInstances);
    return lineInstances;
  }
};

// ../../../node_modules/.pnpm/shikiji@0.8.0/node_modules/shikiji/dist/themes/github-dark.mjs
var githubDark = { name: "github-dark", colors: { focusBorder: "#005cc5", foreground: "#d1d5da", descriptionForeground: "#959da5", errorForeground: "#f97583", "textLink.foreground": "#79b8ff", "textLink.activeForeground": "#c8e1ff", "textBlockQuote.background": "#24292e", "textBlockQuote.border": "#444d56", "textCodeBlock.background": "#2f363d", "textPreformat.foreground": "#d1d5da", "textSeparator.foreground": "#586069", "button.background": "#176f2c", "button.foreground": "#dcffe4", "button.hoverBackground": "#22863a", "button.secondaryBackground": "#444d56", "button.secondaryForeground": "#fff", "button.secondaryHoverBackground": "#586069", "checkbox.background": "#444d56", "checkbox.border": "#1b1f23", "dropdown.background": "#2f363d", "dropdown.border": "#1b1f23", "dropdown.foreground": "#e1e4e8", "dropdown.listBackground": "#24292e", "input.background": "#2f363d", "input.border": "#1b1f23", "input.foreground": "#e1e4e8", "input.placeholderForeground": "#959da5", "badge.foreground": "#c8e1ff", "badge.background": "#044289", "progressBar.background": "#0366d6", "titleBar.activeForeground": "#e1e4e8", "titleBar.activeBackground": "#24292e", "titleBar.inactiveForeground": "#959da5", "titleBar.inactiveBackground": "#1f2428", "titleBar.border": "#1b1f23", "activityBar.foreground": "#e1e4e8", "activityBar.inactiveForeground": "#6a737d", "activityBar.background": "#24292e", "activityBarBadge.foreground": "#fff", "activityBarBadge.background": "#0366d6", "activityBar.activeBorder": "#f9826c", "activityBar.border": "#1b1f23", "sideBar.foreground": "#d1d5da", "sideBar.background": "#1f2428", "sideBar.border": "#1b1f23", "sideBarTitle.foreground": "#e1e4e8", "sideBarSectionHeader.foreground": "#e1e4e8", "sideBarSectionHeader.background": "#1f2428", "sideBarSectionHeader.border": "#1b1f23", "list.hoverForeground": "#e1e4e8", "list.inactiveSelectionForeground": "#e1e4e8", "list.activeSelectionForeground": "#e1e4e8", "list.hoverBackground": "#282e34", "list.inactiveSelectionBackground": "#282e34", "list.activeSelectionBackground": "#39414a", "list.inactiveFocusBackground": "#1d2d3e", "list.focusBackground": "#044289", "tree.indentGuidesStroke": "#2f363d", "notificationCenterHeader.foreground": "#959da5", "notificationCenterHeader.background": "#24292e", "notifications.foreground": "#e1e4e8", "notifications.background": "#2f363d", "notifications.border": "#1b1f23", "notificationsErrorIcon.foreground": "#ea4a5a", "notificationsWarningIcon.foreground": "#ffab70", "notificationsInfoIcon.foreground": "#79b8ff", "pickerGroup.border": "#444d56", "pickerGroup.foreground": "#e1e4e8", "quickInput.background": "#24292e", "quickInput.foreground": "#e1e4e8", "statusBar.foreground": "#d1d5da", "statusBar.background": "#24292e", "statusBar.border": "#1b1f23", "statusBar.noFolderBackground": "#24292e", "statusBar.debuggingBackground": "#931c06", "statusBar.debuggingForeground": "#fff", "statusBarItem.prominentBackground": "#282e34", "statusBarItem.remoteForeground": "#d1d5da", "statusBarItem.remoteBackground": "#24292e", "editorGroupHeader.tabsBackground": "#1f2428", "editorGroupHeader.tabsBorder": "#1b1f23", "editorGroup.border": "#1b1f23", "tab.activeForeground": "#e1e4e8", "tab.inactiveForeground": "#959da5", "tab.inactiveBackground": "#1f2428", "tab.activeBackground": "#24292e", "tab.hoverBackground": "#24292e", "tab.unfocusedHoverBackground": "#24292e", "tab.border": "#1b1f23", "tab.unfocusedActiveBorderTop": "#1b1f23", "tab.activeBorder": "#24292e", "tab.unfocusedActiveBorder": "#24292e", "tab.activeBorderTop": "#f9826c", "breadcrumb.foreground": "#959da5", "breadcrumb.focusForeground": "#e1e4e8", "breadcrumb.activeSelectionForeground": "#d1d5da", "breadcrumbPicker.background": "#2b3036", "editor.foreground": "#e1e4e8", "editor.background": "#24292e", "editorWidget.background": "#1f2428", "editor.foldBackground": "#58606915", "editor.lineHighlightBackground": "#2b3036", "editorLineNumber.foreground": "#444d56", "editorLineNumber.activeForeground": "#e1e4e8", "editorIndentGuide.background": "#2f363d", "editorIndentGuide.activeBackground": "#444d56", "editorWhitespace.foreground": "#444d56", "editorCursor.foreground": "#c8e1ff", "editorError.foreground": "#f97583", "editorWarning.foreground": "#ffea7f", "editor.findMatchBackground": "#ffd33d44", "editor.findMatchHighlightBackground": "#ffd33d22", "editor.linkedEditingBackground": "#3392FF22", "editor.inactiveSelectionBackground": "#3392FF22", "editor.selectionBackground": "#3392FF44", "editor.selectionHighlightBackground": "#17E5E633", "editor.selectionHighlightBorder": "#17E5E600", "editor.wordHighlightBackground": "#17E5E600", "editor.wordHighlightStrongBackground": "#17E5E600", "editor.wordHighlightBorder": "#17E5E699", "editor.wordHighlightStrongBorder": "#17E5E666", "editorBracketMatch.background": "#17E5E650", "editorBracketMatch.border": "#17E5E600", "editorGutter.modifiedBackground": "#2188ff", "editorGutter.addedBackground": "#28a745", "editorGutter.deletedBackground": "#ea4a5a", "diffEditor.insertedTextBackground": "#28a74530", "diffEditor.removedTextBackground": "#d73a4930", "scrollbar.shadow": "#0008", "scrollbarSlider.background": "#6a737d33", "scrollbarSlider.hoverBackground": "#6a737d44", "scrollbarSlider.activeBackground": "#6a737d88", "editorOverviewRuler.border": "#1b1f23", "panel.background": "#1f2428", "panel.border": "#1b1f23", "panelTitle.activeBorder": "#f9826c", "panelTitle.activeForeground": "#e1e4e8", "panelTitle.inactiveForeground": "#959da5", "panelInput.border": "#2f363d", "terminal.foreground": "#d1d5da", "terminal.tab.activeBorder": "#f9826c", "terminalCursor.background": "#586069", "terminalCursor.foreground": "#79b8ff", "terminal.ansiBrightWhite": "#fafbfc", "terminal.ansiWhite": "#d1d5da", "terminal.ansiBrightBlack": "#959da5", "terminal.ansiBlack": "#586069", "terminal.ansiBlue": "#2188ff", "terminal.ansiBrightBlue": "#79b8ff", "terminal.ansiGreen": "#34d058", "terminal.ansiBrightGreen": "#85e89d", "terminal.ansiCyan": "#39c5cf", "terminal.ansiBrightCyan": "#56d4dd", "terminal.ansiRed": "#ea4a5a", "terminal.ansiBrightRed": "#f97583", "terminal.ansiMagenta": "#b392f0", "terminal.ansiBrightMagenta": "#b392f0", "terminal.ansiYellow": "#ffea7f", "terminal.ansiBrightYellow": "#ffea7f", "editorBracketHighlight.foreground1": "#79b8ff", "editorBracketHighlight.foreground2": "#ffab70", "editorBracketHighlight.foreground3": "#b392f0", "editorBracketHighlight.foreground4": "#79b8ff", "editorBracketHighlight.foreground5": "#ffab70", "editorBracketHighlight.foreground6": "#b392f0", "gitDecoration.addedResourceForeground": "#34d058", "gitDecoration.modifiedResourceForeground": "#79b8ff", "gitDecoration.deletedResourceForeground": "#ea4a5a", "gitDecoration.untrackedResourceForeground": "#34d058", "gitDecoration.ignoredResourceForeground": "#6a737d", "gitDecoration.conflictingResourceForeground": "#ffab70", "gitDecoration.submoduleResourceForeground": "#6a737d", "debugToolBar.background": "#2b3036", "editor.stackFrameHighlightBackground": "#C6902625", "editor.focusedStackFrameHighlightBackground": "#2b6a3033", "peekViewEditor.matchHighlightBackground": "#ffd33d33", "peekViewResult.matchHighlightBackground": "#ffd33d33", "peekViewEditor.background": "#1f242888", "peekViewResult.background": "#1f2428", "settings.headerForeground": "#e1e4e8", "settings.modifiedItemIndicator": "#0366d6", "welcomePage.buttonBackground": "#2f363d", "welcomePage.buttonHoverBackground": "#444d56" }, semanticHighlighting: true, tokenColors: [{ scope: ["comment", "punctuation.definition.comment", "string.comment"], settings: { foreground: "#6a737d" } }, { scope: ["constant", "entity.name.constant", "variable.other.constant", "variable.other.enummember", "variable.language"], settings: { foreground: "#79b8ff" } }, { scope: ["entity", "entity.name"], settings: { foreground: "#b392f0" } }, { scope: "variable.parameter.function", settings: { foreground: "#e1e4e8" } }, { scope: "entity.name.tag", settings: { foreground: "#85e89d" } }, { scope: "keyword", settings: { foreground: "#f97583" } }, { scope: ["storage", "storage.type"], settings: { foreground: "#f97583" } }, { scope: ["storage.modifier.package", "storage.modifier.import", "storage.type.java"], settings: { foreground: "#e1e4e8" } }, { scope: ["string", "punctuation.definition.string", "string punctuation.section.embedded source"], settings: { foreground: "#9ecbff" } }, { scope: "support", settings: { foreground: "#79b8ff" } }, { scope: "meta.property-name", settings: { foreground: "#79b8ff" } }, { scope: "variable", settings: { foreground: "#ffab70" } }, { scope: "variable.other", settings: { foreground: "#e1e4e8" } }, { scope: "invalid.broken", settings: { fontStyle: "italic", foreground: "#fdaeb7" } }, { scope: "invalid.deprecated", settings: { fontStyle: "italic", foreground: "#fdaeb7" } }, { scope: "invalid.illegal", settings: { fontStyle: "italic", foreground: "#fdaeb7" } }, { scope: "invalid.unimplemented", settings: { fontStyle: "italic", foreground: "#fdaeb7" } }, { scope: "carriage-return", settings: { fontStyle: "italic underline", background: "#f97583", foreground: "#24292e", content: "^M" } }, { scope: "message.error", settings: { foreground: "#fdaeb7" } }, { scope: "string variable", settings: { foreground: "#79b8ff" } }, { scope: ["source.regexp", "string.regexp"], settings: { foreground: "#dbedff" } }, { scope: ["string.regexp.character-class", "string.regexp constant.character.escape", "string.regexp source.ruby.embedded", "string.regexp string.regexp.arbitrary-repitition"], settings: { foreground: "#dbedff" } }, { scope: "string.regexp constant.character.escape", settings: { fontStyle: "bold", foreground: "#85e89d" } }, { scope: "support.constant", settings: { foreground: "#79b8ff" } }, { scope: "support.variable", settings: { foreground: "#79b8ff" } }, { scope: "meta.module-reference", settings: { foreground: "#79b8ff" } }, { scope: "punctuation.definition.list.begin.markdown", settings: { foreground: "#ffab70" } }, { scope: ["markup.heading", "markup.heading entity.name"], settings: { fontStyle: "bold", foreground: "#79b8ff" } }, { scope: "markup.quote", settings: { foreground: "#85e89d" } }, { scope: "markup.italic", settings: { fontStyle: "italic", foreground: "#e1e4e8" } }, { scope: "markup.bold", settings: { fontStyle: "bold", foreground: "#e1e4e8" } }, { scope: ["markup.underline"], settings: { fontStyle: "underline" } }, { scope: ["markup.strikethrough"], settings: { fontStyle: "strikethrough" } }, { scope: "markup.inline.raw", settings: { foreground: "#79b8ff" } }, { scope: ["markup.deleted", "meta.diff.header.from-file", "punctuation.definition.deleted"], settings: { background: "#86181d", foreground: "#fdaeb7" } }, { scope: ["markup.inserted", "meta.diff.header.to-file", "punctuation.definition.inserted"], settings: { background: "#144620", foreground: "#85e89d" } }, { scope: ["markup.changed", "punctuation.definition.changed"], settings: { background: "#c24e00", foreground: "#ffab70" } }, { scope: ["markup.ignored", "markup.untracked"], settings: { foreground: "#2f363d", background: "#79b8ff" } }, { scope: "meta.diff.range", settings: { foreground: "#b392f0", fontStyle: "bold" } }, { scope: "meta.diff.header", settings: { foreground: "#79b8ff" } }, { scope: "meta.separator", settings: { fontStyle: "bold", foreground: "#79b8ff" } }, { scope: "meta.output", settings: { foreground: "#79b8ff" } }, { scope: ["brackethighlighter.tag", "brackethighlighter.curly", "brackethighlighter.round", "brackethighlighter.square", "brackethighlighter.angle", "brackethighlighter.quote"], settings: { foreground: "#d1d5da" } }, { scope: "brackethighlighter.unmatched", settings: { foreground: "#fdaeb7" } }, { scope: ["constant.other.reference.link", "string.other.link"], settings: { foreground: "#dbedff", fontStyle: "underline" } }] };

// ../../../node_modules/.pnpm/shikiji@0.8.0/node_modules/shikiji/dist/themes/github-light.mjs
var githubLight = { name: "github-light", colors: { focusBorder: "#2188ff", foreground: "#444d56", descriptionForeground: "#6a737d", errorForeground: "#cb2431", "textLink.foreground": "#0366d6", "textLink.activeForeground": "#005cc5", "textBlockQuote.background": "#fafbfc", "textBlockQuote.border": "#e1e4e8", "textCodeBlock.background": "#f6f8fa", "textPreformat.foreground": "#586069", "textSeparator.foreground": "#d1d5da", "button.background": "#159739", "button.foreground": "#fff", "button.hoverBackground": "#138934", "button.secondaryBackground": "#e1e4e8", "button.secondaryForeground": "#1b1f23", "button.secondaryHoverBackground": "#d1d5da", "checkbox.background": "#fafbfc", "checkbox.border": "#d1d5da", "dropdown.background": "#fafbfc", "dropdown.border": "#e1e4e8", "dropdown.foreground": "#2f363d", "dropdown.listBackground": "#fff", "input.background": "#fafbfc", "input.border": "#e1e4e8", "input.foreground": "#2f363d", "input.placeholderForeground": "#959da5", "badge.foreground": "#005cc5", "badge.background": "#dbedff", "progressBar.background": "#2188ff", "titleBar.activeForeground": "#2f363d", "titleBar.activeBackground": "#fff", "titleBar.inactiveForeground": "#6a737d", "titleBar.inactiveBackground": "#f6f8fa", "titleBar.border": "#e1e4e8", "activityBar.foreground": "#2f363d", "activityBar.inactiveForeground": "#959da5", "activityBar.background": "#fff", "activityBarBadge.foreground": "#fff", "activityBarBadge.background": "#2188ff", "activityBar.activeBorder": "#f9826c", "activityBar.border": "#e1e4e8", "sideBar.foreground": "#586069", "sideBar.background": "#f6f8fa", "sideBar.border": "#e1e4e8", "sideBarTitle.foreground": "#2f363d", "sideBarSectionHeader.foreground": "#2f363d", "sideBarSectionHeader.background": "#f6f8fa", "sideBarSectionHeader.border": "#e1e4e8", "list.hoverForeground": "#2f363d", "list.inactiveSelectionForeground": "#2f363d", "list.activeSelectionForeground": "#2f363d", "list.hoverBackground": "#ebf0f4", "list.inactiveSelectionBackground": "#e8eaed", "list.activeSelectionBackground": "#e2e5e9", "list.inactiveFocusBackground": "#dbedff", "list.focusBackground": "#cce5ff", "tree.indentGuidesStroke": "#e1e4e8", "notificationCenterHeader.foreground": "#6a737d", "notificationCenterHeader.background": "#e1e4e8", "notifications.foreground": "#2f363d", "notifications.background": "#fafbfc", "notifications.border": "#e1e4e8", "notificationsErrorIcon.foreground": "#d73a49", "notificationsWarningIcon.foreground": "#e36209", "notificationsInfoIcon.foreground": "#005cc5", "pickerGroup.border": "#e1e4e8", "pickerGroup.foreground": "#2f363d", "quickInput.background": "#fafbfc", "quickInput.foreground": "#2f363d", "statusBar.foreground": "#586069", "statusBar.background": "#fff", "statusBar.border": "#e1e4e8", "statusBar.noFolderBackground": "#fff", "statusBar.debuggingBackground": "#f9826c", "statusBar.debuggingForeground": "#fff", "statusBarItem.prominentBackground": "#e8eaed", "statusBarItem.remoteForeground": "#586069", "statusBarItem.remoteBackground": "#fff", "editorGroupHeader.tabsBackground": "#f6f8fa", "editorGroupHeader.tabsBorder": "#e1e4e8", "editorGroup.border": "#e1e4e8", "tab.activeForeground": "#2f363d", "tab.inactiveForeground": "#6a737d", "tab.inactiveBackground": "#f6f8fa", "tab.activeBackground": "#fff", "tab.hoverBackground": "#fff", "tab.unfocusedHoverBackground": "#fff", "tab.border": "#e1e4e8", "tab.unfocusedActiveBorderTop": "#e1e4e8", "tab.activeBorder": "#fff", "tab.unfocusedActiveBorder": "#fff", "tab.activeBorderTop": "#f9826c", "breadcrumb.foreground": "#6a737d", "breadcrumb.focusForeground": "#2f363d", "breadcrumb.activeSelectionForeground": "#586069", "breadcrumbPicker.background": "#fafbfc", "editor.foreground": "#24292e", "editor.background": "#fff", "editorWidget.background": "#f6f8fa", "editor.foldBackground": "#d1d5da11", "editor.lineHighlightBackground": "#f6f8fa", "editorLineNumber.foreground": "#1b1f234d", "editorLineNumber.activeForeground": "#24292e", "editorIndentGuide.background": "#eff2f6", "editorIndentGuide.activeBackground": "#d7dbe0", "editorWhitespace.foreground": "#d1d5da", "editorCursor.foreground": "#044289", "editorError.foreground": "#cb2431", "editorWarning.foreground": "#f9c513", "editor.findMatchBackground": "#ffdf5d", "editor.findMatchHighlightBackground": "#ffdf5d66", "editor.linkedEditingBackground": "#0366d611", "editor.inactiveSelectionBackground": "#0366d611", "editor.selectionBackground": "#0366d625", "editor.selectionHighlightBackground": "#34d05840", "editor.selectionHighlightBorder": "#34d05800", "editor.wordHighlightBackground": "#34d05800", "editor.wordHighlightStrongBackground": "#34d05800", "editor.wordHighlightBorder": "#24943e99", "editor.wordHighlightStrongBorder": "#24943e50", "editorBracketMatch.background": "#34d05840", "editorBracketMatch.border": "#34d05800", "editorGutter.modifiedBackground": "#2188ff", "editorGutter.addedBackground": "#28a745", "editorGutter.deletedBackground": "#d73a49", "diffEditor.insertedTextBackground": "#34d05822", "diffEditor.removedTextBackground": "#d73a4922", "scrollbar.shadow": "#6a737d33", "scrollbarSlider.background": "#959da533", "scrollbarSlider.hoverBackground": "#959da544", "scrollbarSlider.activeBackground": "#959da588", "editorOverviewRuler.border": "#fff", "panel.background": "#f6f8fa", "panel.border": "#e1e4e8", "panelTitle.activeBorder": "#f9826c", "panelTitle.activeForeground": "#2f363d", "panelTitle.inactiveForeground": "#6a737d", "panelInput.border": "#e1e4e8", "terminal.foreground": "#586069", "terminal.tab.activeBorder": "#f9826c", "terminalCursor.background": "#d1d5da", "terminalCursor.foreground": "#005cc5", "terminal.ansiBrightWhite": "#d1d5da", "terminal.ansiWhite": "#6a737d", "terminal.ansiBrightBlack": "#959da5", "terminal.ansiBlack": "#24292e", "terminal.ansiBlue": "#0366d6", "terminal.ansiBrightBlue": "#005cc5", "terminal.ansiGreen": "#28a745", "terminal.ansiBrightGreen": "#22863a", "terminal.ansiCyan": "#1b7c83", "terminal.ansiBrightCyan": "#3192aa", "terminal.ansiRed": "#d73a49", "terminal.ansiBrightRed": "#cb2431", "terminal.ansiMagenta": "#5a32a3", "terminal.ansiBrightMagenta": "#5a32a3", "terminal.ansiYellow": "#dbab09", "terminal.ansiBrightYellow": "#b08800", "editorBracketHighlight.foreground1": "#005cc5", "editorBracketHighlight.foreground2": "#e36209", "editorBracketHighlight.foreground3": "#5a32a3", "editorBracketHighlight.foreground4": "#005cc5", "editorBracketHighlight.foreground5": "#e36209", "editorBracketHighlight.foreground6": "#5a32a3", "gitDecoration.addedResourceForeground": "#28a745", "gitDecoration.modifiedResourceForeground": "#005cc5", "gitDecoration.deletedResourceForeground": "#d73a49", "gitDecoration.untrackedResourceForeground": "#28a745", "gitDecoration.ignoredResourceForeground": "#959da5", "gitDecoration.conflictingResourceForeground": "#e36209", "gitDecoration.submoduleResourceForeground": "#959da5", "debugToolBar.background": "#fff", "editor.stackFrameHighlightBackground": "#ffd33d33", "editor.focusedStackFrameHighlightBackground": "#28a74525", "settings.headerForeground": "#2f363d", "settings.modifiedItemIndicator": "#2188ff", "welcomePage.buttonBackground": "#f6f8fa", "welcomePage.buttonHoverBackground": "#e1e4e8" }, semanticHighlighting: true, tokenColors: [{ scope: ["comment", "punctuation.definition.comment", "string.comment"], settings: { foreground: "#6a737d" } }, { scope: ["constant", "entity.name.constant", "variable.other.constant", "variable.other.enummember", "variable.language"], settings: { foreground: "#005cc5" } }, { scope: ["entity", "entity.name"], settings: { foreground: "#6f42c1" } }, { scope: "variable.parameter.function", settings: { foreground: "#24292e" } }, { scope: "entity.name.tag", settings: { foreground: "#22863a" } }, { scope: "keyword", settings: { foreground: "#d73a49" } }, { scope: ["storage", "storage.type"], settings: { foreground: "#d73a49" } }, { scope: ["storage.modifier.package", "storage.modifier.import", "storage.type.java"], settings: { foreground: "#24292e" } }, { scope: ["string", "punctuation.definition.string", "string punctuation.section.embedded source"], settings: { foreground: "#032f62" } }, { scope: "support", settings: { foreground: "#005cc5" } }, { scope: "meta.property-name", settings: { foreground: "#005cc5" } }, { scope: "variable", settings: { foreground: "#e36209" } }, { scope: "variable.other", settings: { foreground: "#24292e" } }, { scope: "invalid.broken", settings: { fontStyle: "italic", foreground: "#b31d28" } }, { scope: "invalid.deprecated", settings: { fontStyle: "italic", foreground: "#b31d28" } }, { scope: "invalid.illegal", settings: { fontStyle: "italic", foreground: "#b31d28" } }, { scope: "invalid.unimplemented", settings: { fontStyle: "italic", foreground: "#b31d28" } }, { scope: "carriage-return", settings: { fontStyle: "italic underline", background: "#d73a49", foreground: "#fafbfc", content: "^M" } }, { scope: "message.error", settings: { foreground: "#b31d28" } }, { scope: "string variable", settings: { foreground: "#005cc5" } }, { scope: ["source.regexp", "string.regexp"], settings: { foreground: "#032f62" } }, { scope: ["string.regexp.character-class", "string.regexp constant.character.escape", "string.regexp source.ruby.embedded", "string.regexp string.regexp.arbitrary-repitition"], settings: { foreground: "#032f62" } }, { scope: "string.regexp constant.character.escape", settings: { fontStyle: "bold", foreground: "#22863a" } }, { scope: "support.constant", settings: { foreground: "#005cc5" } }, { scope: "support.variable", settings: { foreground: "#005cc5" } }, { scope: "meta.module-reference", settings: { foreground: "#005cc5" } }, { scope: "punctuation.definition.list.begin.markdown", settings: { foreground: "#e36209" } }, { scope: ["markup.heading", "markup.heading entity.name"], settings: { fontStyle: "bold", foreground: "#005cc5" } }, { scope: "markup.quote", settings: { foreground: "#22863a" } }, { scope: "markup.italic", settings: { fontStyle: "italic", foreground: "#24292e" } }, { scope: "markup.bold", settings: { fontStyle: "bold", foreground: "#24292e" } }, { scope: ["markup.underline"], settings: { fontStyle: "underline" } }, { scope: ["markup.strikethrough"], settings: { fontStyle: "strikethrough" } }, { scope: "markup.inline.raw", settings: { foreground: "#005cc5" } }, { scope: ["markup.deleted", "meta.diff.header.from-file", "punctuation.definition.deleted"], settings: { background: "#ffeef0", foreground: "#b31d28" } }, { scope: ["markup.inserted", "meta.diff.header.to-file", "punctuation.definition.inserted"], settings: { background: "#f0fff4", foreground: "#22863a" } }, { scope: ["markup.changed", "punctuation.definition.changed"], settings: { background: "#ffebda", foreground: "#e36209" } }, { scope: ["markup.ignored", "markup.untracked"], settings: { foreground: "#f6f8fa", background: "#005cc5" } }, { scope: "meta.diff.range", settings: { foreground: "#6f42c1", fontStyle: "bold" } }, { scope: "meta.diff.header", settings: { foreground: "#005cc5" } }, { scope: "meta.separator", settings: { fontStyle: "bold", foreground: "#005cc5" } }, { scope: "meta.output", settings: { foreground: "#005cc5" } }, { scope: ["brackethighlighter.tag", "brackethighlighter.curly", "brackethighlighter.round", "brackethighlighter.square", "brackethighlighter.angle", "brackethighlighter.quote"], settings: { foreground: "#586069" } }, { scope: "brackethighlighter.unmatched", settings: { foreground: "#b31d28" } }, { scope: ["constant.other.reference.link", "string.other.link"], settings: { foreground: "#032f62", fontStyle: "underline" } }] };

// src/internal/render-group.ts
import { h as h4 } from "hastscript";

// src/internal/css.ts
import postcss from "postcss";
import postcssNested from "postcss-nested";

// src/internal/escaping.ts
function escapeRegExp(input) {
  return input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// src/internal/css.ts
var groupWrapperElement = "div";
var groupWrapperClassName = "expressive-code";
var preprocessor = postcss([
  // Prevent top-level selectors that are already scoped from being scoped twice
  (root) => {
    const groupWrapperScope = `.${groupWrapperClassName}`;
    root.walkRules((rule) => {
      if (rule.parent?.parent === root) {
        rule.selectors = rule.selectors.map((selector) => {
          if (selector.indexOf(groupWrapperScope) === 0) {
            return selector.slice(groupWrapperScope.length).trim() || "&";
          }
          return selector;
        });
      }
    });
  },
  // Parse SASS-like nested selectors
  postcssNested()
]);
var processor = postcss([
  // Prevent selectors targeting the wrapper class name or top-level elements from being scoped
  (root) => {
    const groupWrapperScope = escapeRegExp(`.${groupWrapperClassName}`);
    const regExpScopedTopLevel = new RegExp(`^${groupWrapperScope} .*(${groupWrapperScope}|:root|html|body)`, "g");
    root.walkRules((rule) => {
      rule.selectors = rule.selectors.map((selector) => selector.replace(regExpScopedTopLevel, "$1"));
    });
  },
  // Apply some simple minifications
  (root) => {
    root.raws.after = "";
    root.walkComments((comment) => {
      comment.remove();
    });
    root.walkRules((rule) => {
      rule.selector = rule.selectors.join(",");
      rule.raws.before = rule.raws.before?.trim() || "";
      rule.raws.between = "";
      rule.raws.after = "";
      rule.raws.semicolon = false;
    });
    root.walkAtRules((atRule) => {
      atRule.raws.before = atRule.raws.before?.trim() || "";
      atRule.raws.between = "";
      atRule.raws.after = "";
    });
    root.walkDecls((decl) => {
      decl.raws.before = decl.raws.before?.trim() || "";
      decl.raws.between = decl.raws.between?.trim() || ":";
      decl.raws.value = {
        value: decl.value,
        raw: decl.raws.value?.raw.trim() ?? decl.value.trim()
      };
    });
  }
]);
async function scopeAndMinifyNestedCss(css) {
  const postCssOptions = { from: void 0 };
  const root = postcss.parse(`.${groupWrapperClassName}{${css}}`, postCssOptions);
  const preprocessedStyles = await preprocessor.process(root, postCssOptions);
  const processedStyles = await processor.process(preprocessedStyles, postCssOptions);
  return processedStyles.css;
}
var processedStylesCache = /* @__PURE__ */ new Map();
async function processPluginStyles(pluginStyles) {
  const result = /* @__PURE__ */ new Set();
  const seenStyles = /* @__PURE__ */ new Set();
  for (const { pluginName, styles } of pluginStyles) {
    if (seenStyles.has(styles))
      continue;
    seenStyles.add(styles);
    const cacheKey = styles;
    const cachedStyles = processedStylesCache.get(cacheKey);
    if (cachedStyles !== void 0) {
      result.add(cachedStyles);
      continue;
    }
    try {
      const processedCss = await scopeAndMinifyNestedCss(styles);
      result.add(processedCss);
      processedStylesCache.set(cacheKey, processedCss);
    } catch (error) {
      const msg = error instanceof Error ? error.message : error;
      throw new Error(`Plugin "${pluginName}" added CSS styles that could not be processed (error=${JSON.stringify(msg)}). Styles="${styles}"`);
    }
  }
  return result;
}
function wrapInCascadeLayer(css, cascadeLayerName) {
  if (!cascadeLayerName || cascadeLayerName.trim() === "")
    return css;
  return `@layer ${cascadeLayerName.trim()}{${css}}`;
}

// src/internal/render-group.ts
async function renderGroup({
  input,
  options,
  defaultLocale,
  config,
  plugins,
  cssVar,
  cssVarName,
  styleVariants
}) {
  const inputArray = Array.isArray(input) ? input : [input];
  const groupContents = inputArray.map((blockOrOptions) => {
    if (blockOrOptions instanceof ExpressiveCodeBlock) {
      return { codeBlock: blockOrOptions };
    } else {
      return { codeBlock: new ExpressiveCodeBlock(blockOrOptions) };
    }
  });
  Object.freeze(groupContents);
  options?.onInitGroup?.(groupContents);
  const renderedGroupContents = groupContents;
  const pluginStyles = [];
  for (const groupContent of renderedGroupContents) {
    const { renderedBlockAst, blockStyles } = await renderBlock({
      codeBlock: groupContent.codeBlock,
      groupContents,
      locale: groupContent.codeBlock.locale || defaultLocale,
      config,
      plugins,
      cssVar,
      cssVarName,
      styleVariants
    });
    groupContent.renderedBlockAst = renderedBlockAst;
    pluginStyles.push(...blockStyles);
  }
  const groupRenderData = {
    groupAst: h4(
      null,
      renderedGroupContents.map(({ renderedBlockAst }) => renderedBlockAst)
    )
  };
  await runHooks("postprocessRenderedBlockGroup", plugins, async ({ hookFn, plugin }) => {
    await hookFn({
      renderedGroupContents,
      pluginStyles,
      addStyles: (styles) => pluginStyles.push({ pluginName: plugin.name, styles }),
      renderData: groupRenderData
    });
    if (!isHastParent(groupRenderData.groupAst)) {
      throw newTypeError("hast Parent", groupRenderData.groupAst, "groupAst");
    }
  });
  return {
    renderedGroupAst: addWrapperAroundGroupAst({ groupAst: groupRenderData.groupAst }),
    renderedGroupContents,
    styles: await processPluginStyles(pluginStyles)
  };
}
function addWrapperAroundGroupAst({ groupAst }) {
  return h4(`${groupWrapperElement}.${groupWrapperClassName}`, groupAst);
}

// src/helpers/color-transforms.ts
import { TinyColor, readability } from "@ctrl/tinycolor";

// ../../../node_modules/.pnpm/culori@3.2.0/node_modules/culori/src/lrgb/convertRgbToLrgb.js
var fn = (c) => {
  const abs = Math.abs(c);
  if (abs < 0.04045) {
    return c / 12.92;
  }
  return (Math.sign(c) || 1) * Math.pow((abs + 0.055) / 1.055, 2.4);
};
var convertRgbToLrgb = ({ r, g, b, alpha }) => {
  let res = {
    mode: "lrgb",
    r: fn(r),
    g: fn(g),
    b: fn(b)
  };
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertRgbToLrgb_default = convertRgbToLrgb;

// ../../../node_modules/.pnpm/culori@3.2.0/node_modules/culori/src/lrgb/convertLrgbToRgb.js
var fn2 = (c) => {
  const abs = Math.abs(c);
  if (abs > 31308e-7) {
    return (Math.sign(c) || 1) * (1.055 * Math.pow(abs, 1 / 2.4) - 0.055);
  }
  return c * 12.92;
};
var convertLrgbToRgb = ({ r, g, b, alpha }, mode = "rgb") => {
  let res = {
    mode,
    r: fn2(r),
    g: fn2(g),
    b: fn2(b)
  };
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertLrgbToRgb_default = convertLrgbToRgb;

// ../../../node_modules/.pnpm/culori@3.2.0/node_modules/culori/src/util/normalizeHue.js
var normalizeHue = (hue) => (hue = hue % 360) < 0 ? hue + 360 : hue;
var normalizeHue_default = normalizeHue;

// ../../../node_modules/.pnpm/culori@3.2.0/node_modules/culori/src/lch/convertLabToLch.js
var convertLabToLch = ({ l, a, b, alpha }, mode = "lch") => {
  let c = Math.sqrt(a * a + b * b);
  let res = { mode, l, c };
  if (c)
    res.h = normalizeHue_default(Math.atan2(b, a) * 180 / Math.PI);
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertLabToLch_default = convertLabToLch;

// ../../../node_modules/.pnpm/culori@3.2.0/node_modules/culori/src/lch/convertLchToLab.js
var convertLchToLab = ({ l, c, h: h5, alpha }, mode = "lab") => {
  let res = {
    mode,
    l,
    a: c ? c * Math.cos(h5 / 180 * Math.PI) : 0,
    b: c ? c * Math.sin(h5 / 180 * Math.PI) : 0
  };
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
};
var convertLchToLab_default = convertLchToLab;

// ../../../node_modules/.pnpm/culori@3.2.0/node_modules/culori/src/hsl/convertHslToRgb.js
function convertHslToRgb({ h: h5, s, l, alpha }) {
  h5 = normalizeHue_default(h5);
  let m1 = l + s * (l < 0.5 ? l : 1 - l);
  let m2 = m1 - (m1 - l) * 2 * Math.abs(h5 / 60 % 2 - 1);
  let res;
  switch (Math.floor(h5 / 60)) {
    case 0:
      res = { r: m1, g: m2, b: 2 * l - m1 };
      break;
    case 1:
      res = { r: m2, g: m1, b: 2 * l - m1 };
      break;
    case 2:
      res = { r: 2 * l - m1, g: m1, b: m2 };
      break;
    case 3:
      res = { r: 2 * l - m1, g: m2, b: m1 };
      break;
    case 4:
      res = { r: m2, g: 2 * l - m1, b: m1 };
      break;
    case 5:
      res = { r: m1, g: 2 * l - m1, b: m2 };
      break;
    default:
      res = { r: 2 * l - m1, g: 2 * l - m1, b: 2 * l - m1 };
  }
  res.mode = "rgb";
  if (alpha !== void 0)
    res.alpha = alpha;
  return res;
}

// ../../../node_modules/.pnpm/culori@3.2.0/node_modules/culori/src/oklab/convertLrgbToOklab.js
var convertLrgbToOklab = ({ r, g, b, alpha }) => {
  let L = Math.cbrt(
    0.41222147079999993 * r + 0.5363325363 * g + 0.0514459929 * b
  );
  let M = Math.cbrt(
    0.2119034981999999 * r + 0.6806995450999999 * g + 0.1073969566 * b
  );
  let S = Math.cbrt(
    0.08830246189999998 * r + 0.2817188376 * g + 0.6299787005000002 * b
  );
  let res = {
    mode: "oklab",
    l: 0.2104542553 * L + 0.793617785 * M - 0.0040720468 * S,
    a: 1.9779984951 * L - 2.428592205 * M + 0.4505937099 * S,
    b: 0.0259040371 * L + 0.7827717662 * M - 0.808675766 * S
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertLrgbToOklab_default = convertLrgbToOklab;

// ../../../node_modules/.pnpm/culori@3.2.0/node_modules/culori/src/oklab/convertRgbToOklab.js
var convertRgbToOklab = (rgb) => {
  let res = convertLrgbToOklab_default(convertRgbToLrgb_default(rgb));
  if (rgb.r === rgb.b && rgb.b === rgb.g) {
    res.a = res.b = 0;
  }
  return res;
};
var convertRgbToOklab_default = convertRgbToOklab;

// ../../../node_modules/.pnpm/culori@3.2.0/node_modules/culori/src/oklab/convertOklabToLrgb.js
var convertOklabToLrgb = ({ l, a, b, alpha }) => {
  let L = Math.pow(
    l * 0.9999999984505198 + 0.39633779217376786 * a + 0.2158037580607588 * b,
    3
  );
  let M = Math.pow(
    l * 1.0000000088817609 - 0.10556134232365635 * a - 0.06385417477170591 * b,
    3
  );
  let S = Math.pow(
    l * 1.0000000546724108 - 0.08948418209496575 * a - 1.2914855378640917 * b,
    3
  );
  let res = {
    mode: "lrgb",
    r: 4.076741661347994 * L - 3.307711590408193 * M + 0.230969928729428 * S,
    g: -1.2684380040921763 * L + 2.6097574006633715 * M - 0.3413193963102197 * S,
    b: -0.004196086541837188 * L - 0.7034186144594493 * M + 1.7076147009309444 * S
  };
  if (alpha !== void 0) {
    res.alpha = alpha;
  }
  return res;
};
var convertOklabToLrgb_default = convertOklabToLrgb;

// ../../../node_modules/.pnpm/culori@3.2.0/node_modules/culori/src/oklab/convertOklabToRgb.js
var convertOklabToRgb = (c) => convertLrgbToRgb_default(convertOklabToLrgb_default(c));
var convertOklabToRgb_default = convertOklabToRgb;

// src/internal/search-algorithms.ts
function binarySearch({
  getValueFn,
  targetValue,
  preferHigher,
  tolerance = 0.1,
  low = 0,
  high = 1,
  minChangeFactor = 1e-3,
  maxIterations = 25
}) {
  const epsilon = minChangeFactor * Math.abs(high - low);
  let iterations = 0;
  let mid;
  let lastMid;
  while (mid = (low + high) / 2, iterations < maxIterations) {
    const currentValue = getValueFn(mid);
    const resultIsWithinTolerance = Math.abs(currentValue - targetValue) <= tolerance;
    const resultIsInPreferredDirection = preferHigher === void 0 ? true : preferHigher ? currentValue > targetValue : currentValue < targetValue;
    const midChangedLessThanEpsilon = lastMid !== void 0 && Math.abs(lastMid - mid) < epsilon;
    if (resultIsInPreferredDirection && (resultIsWithinTolerance || midChangedLessThanEpsilon)) {
      return mid;
    } else if (currentValue < targetValue) {
      low = mid;
    } else {
      high = mid;
    }
    iterations++;
    lastMid = mid;
  }
  return mid;
}
function bisect({
  checkFn,
  low = 0,
  high = 1,
  /**
   * If the midpoint changes less than `minChangeFactor * Math.abs(high - low)`
   * between iterations, the search will stop and return the highest value
   * that `checkFn` returned `true` for.
   */
  minChangeFactor = 1e-3,
  maxIterations = 25
}) {
  const epsilon = minChangeFactor * Math.abs(high - low);
  let iterations = 0;
  let highestValid;
  let mid;
  let lastMid;
  while (mid = (low + high) / 2, iterations < maxIterations) {
    const isValid = checkFn(mid);
    if (isValid) {
      highestValid = mid;
      low = mid;
    } else {
      high = mid;
    }
    const midChangedLessThanEpsilon = lastMid !== void 0 && Math.abs(lastMid - mid) < epsilon;
    if (midChangedLessThanEpsilon)
      return highestValid;
    iterations++;
    lastMid = mid;
  }
  return highestValid;
}

// src/internal/color-spaces.ts
var D65 = [0.3127 / 0.329, 1, (1 - 0.3127 - 0.329) / 0.329];
var D50 = [0.3457 / 0.3585, 1, (1 - 0.3457 - 0.3585) / 0.3585];
var m = [
  [3.240969941904521, -1.537383177570093, -0.498610760293],
  [-0.96924363628087, 1.87596750150772, 0.041555057407175],
  [0.055630079696993, -0.20397695888897, 1.056971514242878]
];
function xyzToRgb(xyz) {
  const [x, y, z] = [xyz.x, xyz.y, xyz.z].map((v) => v / 100);
  const linearToSrgb = (v) => v > 31308e-7 ? 1.055 * Math.pow(v, 1 / 2.4) - 0.055 : 12.92 * v;
  const r = x * m[0][0] + y * m[0][1] + z * m[0][2];
  const g = x * m[1][0] + y * m[1][1] + z * m[1][2];
  const b = x * m[2][0] + y * m[2][1] + z * m[2][2];
  return {
    r: linearToSrgb(r) * 255,
    g: linearToSrgb(g) * 255,
    b: linearToSrgb(b) * 255
  };
}
function labToXyz(lab, illuminant = D65) {
  const [l, a, b] = [lab.l, lab.a, lab.b].map((v) => v / 100);
  const y = (l + 0.16) / 1.16;
  const x = a / 5 + y;
  const z = y - b / 2;
  const transform = (v, whitepoint) => {
    const pow = Math.pow(v, 3);
    return (pow > 8856e-6 ? pow : (v - 16 / 116) / 7.787037) * whitepoint;
  };
  return {
    x: transform(x, illuminant[0]) * 100,
    y: transform(y, illuminant[1]) * 100,
    z: transform(z, illuminant[2]) * 100
  };
}
function lchabToLab(lch) {
  return {
    l: lch.l,
    a: lch.c * Math.cos((lch.h ?? 0) * Math.PI / 180),
    b: lch.c * Math.sin((lch.h ?? 0) * Math.PI / 180),
    alpha: lch.alpha
  };
}
function labToRgba(lab, illuminant = D65) {
  const xyz = labToXyz(lab, illuminant);
  return {
    ...xyzToRgb(xyz),
    a: lab.alpha
  };
}
function lchabToRgba(lch, illuminant = D65) {
  return labToRgba(lchabToLab(lch), illuminant);
}
function rgbaToCulori(rgba) {
  const { r, g, b, a } = rgba;
  return {
    mode: "rgb",
    r: r / 255,
    g: g / 255,
    b: b / 255,
    ...a !== void 0 && { alpha: a }
  };
}
function rgbaFromCulori(culoriRgb) {
  const { r, g, b, alpha } = culoriRgb;
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255,
    a: alpha
  };
}
function hslToRgba(input) {
  return rgbaFromCulori(convertHslToRgb(input));
}
function rgbaToOklch(input) {
  const oklab = convertRgbToOklab_default(rgbaToCulori(input));
  return convertLabToLch_default(oklab, "oklch");
}
function oklchToRgba(input, clampChroma = true) {
  const convert = (oklch) => {
    const oklab = convertLchToLab_default(oklch, "oklab");
    const rgb = convertOklabToRgb_default(oklab);
    const minChannel = Math.min(rgb.r, rgb.g, rgb.b);
    const maxChannel = Math.max(rgb.r, rgb.g, rgb.b);
    const inGamut = minChannel >= 0 && maxChannel <= 1;
    return {
      rgb,
      c: oklch.c,
      inGamut
    };
  };
  let result = convert(input);
  if (!result.inGamut && clampChroma) {
    result = convert({ ...input, c: 0 });
    if (result.inGamut) {
      const maxChromaInGamut = bisect({
        checkFn: (c) => convert({ ...input, c }).inGamut,
        low: 0,
        high: input.c,
        minChangeFactor: 1e-4
      });
      result = convert({ ...input, c: maxChromaInGamut ?? 0 });
    }
  }
  return rgbaFromCulori(result.rgb);
}
function normalizeAngle(angle) {
  angle %= 360;
  return angle < 0 ? angle + 360 : angle;
}
function parseAngle(value) {
  return normalizeAngle(parseFloat(value));
}
function parseCssLabColor(labString) {
  const match = labString.match(/^lab\(\s*([\d.]+%?)\s+(-?[\d.]+%?)\s+(-?[\d.]+%?)(?:\s*\/\s*([\d.]+%?))?\s*\)$/i);
  if (!match) {
    return void 0;
  }
  const [, l, a, b, alpha] = match;
  return {
    l: parseCssValue(l, 0, 100),
    a: parseCssValue(a, -125, 125),
    b: parseCssValue(b, -125, 125),
    alpha: alpha !== void 0 ? parseCssValue(alpha, 0, 1) : void 0
  };
}
function parseCssLchColor(lchString) {
  const match = lchString.match(/^lch\(\s*([\d.]+%?)\s+([\d.]+%?)\s+([\d.]+(?:deg)?)(?:\s*\/\s*([\d.]+%?))?\s*\)$/i);
  if (!match) {
    return void 0;
  }
  const [, l, c, h5, alpha] = match;
  return {
    l: parseCssValue(l, 0, 100),
    c: parseCssValue(c, 0, 150),
    h: parseAngle(h5),
    alpha: alpha !== void 0 ? parseCssValue(alpha, 0, 1) : void 0
  };
}
function parseCssOklchColor(oklchString) {
  const match = oklchString.match(/^oklch\(\s*([\d.]+%?)\s+([\d.]+%?)\s+([\d.]+(?:deg)?)(?:\s*\/\s*([\d.]+%?))?\s*\)$/i);
  if (!match) {
    return void 0;
  }
  const [, l, c, h5, alpha] = match;
  return {
    mode: "oklch",
    l: parseCssValue(l, 0, 1),
    c: parseCssValue(c, 0, 0.5, 0.4),
    h: parseAngle(h5),
    ...alpha !== void 0 && { alpha: parseCssValue(alpha, 0, 1) }
  };
}
function parseCssValue(value, min, max, valueFor100Percent) {
  const isPercentage = value.endsWith("%");
  const floatValue = parseFloat(value);
  const convertedValue = isPercentage ? floatValue * (valueFor100Percent ?? max) / 100 : floatValue;
  return Math.max(min, Math.min(max, convertedValue));
}

// src/helpers/color-transforms.ts
function setAlpha(input, newAlpha) {
  return withParsedColor(input, (color) => {
    return toHexColor(color.setAlpha(newAlpha));
  });
}
function multiplyAlpha(input, factor) {
  return withParsedColor(input, (color) => {
    return toHexColor(color.setAlpha(minMaxRounded(color.getAlpha() * factor)));
  });
}
function getLuminance(input) {
  return toTinyColor(input).getLuminance();
}
function setLuminance(input, targetLuminance) {
  return withParsedColor(input, (color) => {
    targetLuminance = minMaxRounded(targetLuminance);
    const increasing = targetLuminance > color.getLuminance();
    const mixColor = increasing ? "#fff" : "#000";
    const mixAmount = binarySearch({
      getValueFn: (amount) => {
        return toTinyColor(color).mix(mixColor, amount * 100).getLuminance();
      },
      targetValue: targetLuminance,
      preferHigher: targetLuminance > 0 && targetLuminance < 1 ? increasing : void 0,
      tolerance: 1 / 256,
      // Ensure that the binary search range matches the luminance target direction
      low: increasing ? 0 : 1,
      high: increasing ? 1 : 0
    });
    return toHexColor(color.mix(mixColor, mixAmount * 100));
  });
}
function lighten(input, amount) {
  return withParsedColor(input, (color) => {
    const hsl = color.toHsl();
    const l = minMaxRounded(hsl.l);
    const { h: h5, s, a: alpha } = hsl;
    return toHexColor(toTinyColor({ mode: "hsl", h: h5, s, l: minMaxRounded(l + l * amount), alpha }));
  });
}
function darken(input, amount) {
  return lighten(input, -amount);
}
function mix(input, mixinInput, amount) {
  return withParsedColor(input, (color) => {
    const mixinColor = toTinyColor(mixinInput);
    const mixAmount = minMaxRounded(amount * 100, 0, 100);
    return toHexColor(color.mix(mixinColor, mixAmount));
  });
}
function onBackground(input, background) {
  return withParsedColor(
    input,
    (color) => {
      const backgroundColor = toTinyColor(background);
      return toHexColor(color.onBackground(backgroundColor));
    },
    background
  );
}
function getColorContrast(color1, color2) {
  const color = toTinyColor(color1);
  const backgroundColor = toTinyColor(color2);
  return readability(color, backgroundColor);
}
function getColorContrastOnBackground(input, background) {
  const color = toTinyColor(input);
  const backgroundColor = toTinyColor(background);
  return readability(color.onBackground(backgroundColor), backgroundColor);
}
function ensureColorContrastOnBackground(input, background, minContrast = 5.5, maxContrast = 22) {
  return withParsedColor(input, (color) => {
    return withParsedColor(
      background,
      (backgroundColor) => {
        const hexBackgroundColor = toHexColor(backgroundColor);
        let newColor = toTinyColor(color);
        let curContrast = readability(newColor.onBackground(backgroundColor), backgroundColor);
        if (curContrast < minContrast) {
          const contrastWithoutAlpha = readability(newColor, backgroundColor);
          if (contrastWithoutAlpha < minContrast) {
            newColor = toTinyColor(changeLuminanceToReachColorContrast(toHexColor(newColor), hexBackgroundColor, minContrast));
            curContrast = readability(newColor.onBackground(backgroundColor), backgroundColor);
          }
        }
        if (curContrast < minContrast || curContrast > maxContrast) {
          newColor = toTinyColor(changeAlphaToReachColorContrast(toHexColor(newColor), hexBackgroundColor, minContrast, maxContrast));
        }
        return toHexColor(newColor);
      },
      toHexColor(color)
    );
  });
}
function changeLuminanceToReachColorContrast(input1, input2, minContrast = 6) {
  const color1 = toTinyColor(input1);
  const color2 = toTinyColor(input2);
  const oldContrast = readability(color1, color2);
  if (oldContrast >= minContrast)
    return toHexColor(color1);
  const color1L = color1.getLuminance();
  const color2L = color2.getLuminance();
  const lightenTargetL = (color2L + 0.05) * minContrast - 0.05;
  const darkenTargetL = (color2L + 0.05) / minContrast - 0.05;
  const lightenedColor = setLuminance(input1, lightenTargetL);
  const darkenedColor = setLuminance(input1, darkenTargetL);
  const lightenedContrast = readability(lightenedColor, color2);
  const darkenedContrast = readability(darkenedColor, color2);
  if (lightenedContrast <= oldContrast && darkenedContrast <= oldContrast)
    return toHexColor(color1);
  if (color1L >= color2L && lightenedContrast >= minContrast)
    return lightenedColor;
  if (color1L < color2L && darkenedContrast >= minContrast)
    return darkenedColor;
  return lightenedContrast > darkenedContrast ? lightenedColor : darkenedColor;
}
function changeAlphaToReachColorContrast(input, background, minContrast = 6, maxContrast = 22) {
  const color = toTinyColor(input);
  const backgroundColor = toTinyColor(background);
  const colorOnBackground = color.onBackground(backgroundColor);
  const curContrast = readability(colorOnBackground, backgroundColor);
  if (curContrast >= minContrast && curContrast <= maxContrast)
    return toHexColor(color);
  const newAlpha = binarySearch({
    getValueFn: (alpha) => {
      const newColor = toTinyColor(color).setAlpha(alpha);
      const onBg = newColor.onBackground(backgroundColor);
      const result = readability(onBg, backgroundColor);
      return result;
    },
    targetValue: curContrast < minContrast ? minContrast : maxContrast,
    preferHigher: curContrast < minContrast,
    tolerance: 1 / 256,
    low: 0.15,
    high: 1
  });
  return setAlpha(toHexColor(color), newAlpha);
}
function chromaticRecolor(input, target) {
  let targetHue;
  let targetChroma;
  let targetChromaMeasuredAtLightness;
  if (typeof target === "string") {
    const targetOklch = rgbaToOklch(toTinyColor(target));
    targetHue = targetOklch.h ?? 0;
    targetChroma = targetOklch.c;
    targetChromaMeasuredAtLightness = targetOklch.l;
  } else {
    targetHue = target.hue;
    targetChroma = target.chroma;
    targetChromaMeasuredAtLightness = target.chromaMeasuredAtLightness;
  }
  return withParsedColor(input, (color) => {
    const oklch = rgbaToOklch(color);
    oklch.h = targetHue;
    const maxChromaForInputLightness = rgbaToOklch(oklchToRgba({ ...oklch, c: 0.4 })).c;
    let newChroma;
    if (targetChromaMeasuredAtLightness !== void 0) {
      const maxChromaForTargetLightness = rgbaToOklch(oklchToRgba({ ...oklch, c: 0.4, l: targetChromaMeasuredAtLightness })).c;
      const relativeTargetChroma = Math.min(targetChroma, maxChromaForTargetLightness) / maxChromaForTargetLightness;
      newChroma = maxChromaForInputLightness * relativeTargetChroma;
    } else {
      newChroma = Math.min(targetChroma, maxChromaForInputLightness);
    }
    const linearDecrease = (i, start, end) => Math.max(0, Math.min(1, 1 - (i - start) / (end - start)));
    const highLightnessFactor = linearDecrease(oklch.l, 0.95, 0.99);
    oklch.c = newChroma * highLightnessFactor;
    return toHexColor(toTinyColor(oklchToRgba(oklch, true)));
  });
}
function withParsedColor(input, transform, fallback) {
  const color = input && toTinyColor(input);
  if (!color || !color.isValid) {
    const fallbackOrInput = fallback !== void 0 ? fallback : input;
    return !fallbackOrInput || typeof fallbackOrInput === "string" ? fallbackOrInput : toHexColor(fallbackOrInput);
  }
  return transform(color);
}
function toTinyColor(input) {
  if (input instanceof TinyColor) {
    return new TinyColor(input.toHexShortString());
  }
  if (typeof input === "string") {
    const labColor = parseCssLabColor(input);
    if (labColor) {
      return new TinyColor(labToRgba(labColor));
    }
    const lchColor = parseCssLchColor(input);
    if (lchColor) {
      return new TinyColor(lchabToRgba(lchColor));
    }
    const oklchColor = parseCssOklchColor(input);
    if (oklchColor) {
      return new TinyColor(oklchToRgba(oklchColor));
    }
    return new TinyColor(input);
  }
  if (typeof input === "object" && "mode" in input) {
    if (input.mode === "hsl")
      return new TinyColor(hslToRgba(input));
    if (input.mode === "oklch")
      return new TinyColor(oklchToRgba(input));
  }
  return new TinyColor(input);
}
function toHexColor(input) {
  const color = input instanceof TinyColor ? input : toTinyColor(input);
  return color.toHexShortString();
}
function toRgbaString(input) {
  return toTinyColor(input).toRgbString().toLowerCase();
}
function roundFloat(number, decimalPoints) {
  const decimal = Math.pow(10, decimalPoints);
  return Math.round(number * decimal) / decimal;
}
function minMaxRounded(number, min = 0, max = 1, decimalPoints = 3) {
  return Math.max(min, Math.min(max, roundFloat(number, decimalPoints)));
}

// src/internal/vscode-colors.ts
var groupedDefaultWorkbenchColorKeys = {
  backgrounds: [
    "editor.background",
    "editorGroupHeader.tabsBackground",
    "editorGroupHeader.tabsBorder",
    "titleBar.activeBackground",
    "titleBar.border",
    "panel.background",
    "tab.activeBackground",
    "tab.activeBorderTop",
    "tab.activeBorder",
    "terminal.background",
    "widget.shadow"
  ],
  accents: [
    "focusBorder",
    "editor.selectionBackground",
    "textBlockQuote.border",
    "textLink.activeForeground",
    "textLink.foreground",
    "editorLink.activeForeground",
    "tab.activeForeground",
    "tab.inactiveForeground",
    "tab.unfocusedActiveForeground",
    "tab.unfocusedInactiveForeground"
  ]
};
var defaultEditorBackgroundColors = ["#1e1e1e", "#ffffff"];
var defaultEditorForegroundColors = ["#bbbbbb", "#333333"];
var defaultWorkbenchColors = {
  // Base colors
  focusBorder: ["#007fd4", "#0090f1"],
  foreground: ["#cccccc", "#616161"],
  disabledForeground: ["#cccccc80", "#61616180"],
  descriptionForeground: [["transparent", "foreground", 0.7], "#717171"],
  errorForeground: ["#f48771", "#a1260d"],
  "icon.foreground": ["#c5c5c5", "#424242"],
  // Contrast colors
  contrastActiveBorder: null,
  contrastBorder: null,
  // Colors inside a text document, such as the welcome page
  "textBlockQuote.background": ["#7f7f7f1a", "#7f7f7f1a"],
  "textBlockQuote.border": ["#007acc80", "#007acc80"],
  "textCodeBlock.background": ["#0a0a0a66", "#dcdcdc66"],
  "textLink.activeForeground": ["#3794ff", "#006ab1"],
  "textLink.foreground": ["#3794ff", "#006ab1"],
  "textPreformat.foreground": ["#d7ba7d", "#a31515"],
  "textSeparator.foreground": ["#ffffff2e", "#0000002e"],
  // Editor colors
  "editor.background": defaultEditorBackgroundColors,
  "editor.foreground": defaultEditorForegroundColors,
  "editorLineNumber.foreground": ["#858585", "#237893"],
  "editorLineNumber.activeForeground": "editorActiveLineNumber.foreground",
  "editorActiveLineNumber.foreground": ["#c6c6c6", "#0b216f"],
  "editor.selectionBackground": ["#264f78", "#add6ff"],
  "editor.inactiveSelectionBackground": ["transparent", "editor.selectionBackground", 0.5],
  "editor.selectionHighlightBackground": ["lessProminent", "editor.selectionBackground", "editor.background", 0.3, 0.6],
  // Editor status colors & icons
  "editorError.foreground": ["#f14c4c", "#e51400"],
  "editorWarning.foreground": ["#cca700", "#bf8803"],
  "editorInfo.foreground": ["#3794ff", "#1a85ff"],
  "editorHint.foreground": ["#eeeeeeb2", "#6c6c6c"],
  "problemsErrorIcon.foreground": "editorError.foreground",
  "problemsWarningIcon.foreground": "editorWarning.foreground",
  "problemsInfoIcon.foreground": "editorInfo.foreground",
  // Editor find matches
  "editor.findMatchBackground": ["#515c6a", "#a8ac94"],
  "editor.findMatchHighlightBackground": ["#ea5c0055", "#ea5c0055"],
  "editor.findRangeHighlightBackground": ["#3a3d4166", "#b4b4b44d"],
  // Editor links
  "editorLink.activeForeground": ["#4e94ce", "#0000ff"],
  // Editor lightbulb icons
  "editorLightBulb.foreground": ["#ffcc00", "#ddb100"],
  "editorLightBulbAutoFix.foreground": ["#75beff", "#007acc"],
  // Editor diffs
  "diffEditor.insertedTextBackground": ["#9ccc2c33", "#9ccc2c40"],
  "diffEditor.insertedTextBorder": null,
  "diffEditor.removedTextBackground": ["#ff000033", "#ff000033"],
  "diffEditor.removedTextBorder": null,
  "diffEditor.insertedLineBackground": ["#9bb95533", "#9bb95533"],
  "diffEditor.removedLineBackground": ["#ff000033", "#ff000033"],
  // Editor sticky scroll
  "editorStickyScroll.background": "editor.background",
  "editorStickyScrollHover.background": ["#2a2d2e", "#f0f0f0"],
  // Editor inlays (hints displayed inside an editor line)
  "editorInlayHint.background": [
    ["transparent", "badge.background", 0.8],
    ["transparent", "badge.background", 0.6]
  ],
  "editorInlayHint.foreground": "badge.foreground",
  "editorInlayHint.typeBackground": "editorInlayHint.background",
  "editorInlayHint.typeForeground": "editorInlayHint.foreground",
  "editorInlayHint.parameterBackground": "editorInlayHint.background",
  "editorInlayHint.parameterForeground": "editorInlayHint.foreground",
  // Editor groups & panes
  "editorPane.background": ["editor.background", "editor.background"],
  "editorGroup.emptyBackground": null,
  "editorGroup.focusedEmptyBorder": null,
  "editorGroupHeader.tabsBackground": ["#252526", "#f3f3f3"],
  "editorGroupHeader.tabsBorder": null,
  "editorGroupHeader.noTabsBackground": ["editor.background", "editor.background"],
  "editorGroupHeader.border": null,
  "editorGroup.border": ["#444444", "#e7e7e7"],
  "editorGroup.dropBackground": ["#53595d80", "#2677cb2d"],
  "editorGroup.dropIntoPromptForeground": ["editorWidget.foreground", "editorWidget.foreground"],
  "editorGroup.dropIntoPromptBackground": ["editorWidget.background", "editorWidget.background"],
  "editorGroup.dropIntoPromptBorder": null,
  "sideBySideEditor.horizontalBorder": ["editorGroup.border", "editorGroup.border"],
  "sideBySideEditor.verticalBorder": ["editorGroup.border", "editorGroup.border"],
  // Scrollbars
  "scrollbar.shadow": ["#000000", "#dddddd"],
  "scrollbarSlider.background": ["#79797966", "#64646466"],
  "scrollbarSlider.hoverBackground": ["#646464b2", "#646464b2"],
  "scrollbarSlider.activeBackground": ["#bfbfbf66", "#00000099"],
  // Panels
  "panel.background": "editor.background",
  "panel.border": "#80808059",
  "panelTitle.activeBorder": "panelTitle.activeForeground",
  "panelTitle.activeForeground": ["#e7e7e7", "#424242"],
  "panelTitle.inactiveForeground": [
    ["transparent", "panelTitle.activeForeground", 0.6],
    ["transparent", "panelTitle.activeForeground", 0.75]
  ],
  "panelSectionHeader.background": "#80808051",
  "terminal.background": "panel.background",
  // Widgets
  "widget.shadow": ["#0000005b", "#00000028"],
  "editorWidget.background": ["#252526", "#f3f3f3"],
  "editorWidget.foreground": "foreground",
  "editorWidget.border": ["#454545", "#c8c8c8"],
  "quickInput.background": "editorWidget.background",
  "quickInput.foreground": "editorWidget.foreground",
  "quickInputTitle.background": ["#ffffff1a", "#0000000f"],
  "pickerGroup.foreground": ["#3794ff", "#0066bf"],
  "pickerGroup.border": ["#3f3f46", "#cccedb"],
  "editor.hoverHighlightBackground": ["#264f7840", "#add6ff26"],
  "editorHoverWidget.background": "editorWidget.background",
  "editorHoverWidget.foreground": "editorWidget.foreground",
  "editorHoverWidget.border": "editorWidget.border",
  "editorHoverWidget.statusBarBackground": [
    ["lighten", "editorHoverWidget.background", 0.2],
    ["darken", "editorHoverWidget.background", 0.05]
  ],
  // Title bar
  "titleBar.activeBackground": ["#3c3c3c", "#dddddd"],
  "titleBar.activeForeground": ["#cccccc", "#333333"],
  "titleBar.inactiveBackground": ["transparent", "titleBar.activeBackground", 0.6],
  "titleBar.inactiveForeground": ["transparent", "titleBar.activeForeground", 0.6],
  "titleBar.border": null,
  // Toolbars
  "toolbar.hoverBackground": ["#5a5d5e50", "#b8b8b850"],
  "toolbar.activeBackground": [
    ["lighten", "toolbar.hoverBackground", 0.1],
    ["darken", "toolbar.hoverBackground", 0.1]
  ],
  // Tab background
  "tab.activeBackground": ["editor.background", "editor.background"],
  "tab.unfocusedActiveBackground": ["tab.activeBackground", "tab.activeBackground"],
  "tab.inactiveBackground": ["#2d2d2d", "#ececec"],
  "tab.unfocusedInactiveBackground": ["tab.inactiveBackground", "tab.inactiveBackground"],
  // Tab foreground
  "tab.activeForeground": ["#ffffff", "#333333"],
  "tab.inactiveForeground": [
    ["transparent", "tab.activeForeground", 0.5],
    ["transparent", "tab.activeForeground", 0.7]
  ],
  "tab.unfocusedActiveForeground": [
    ["transparent", "tab.activeForeground", 0.5],
    ["transparent", "tab.activeForeground", 0.7]
  ],
  "tab.unfocusedInactiveForeground": [
    ["transparent", "tab.inactiveForeground", 0.5],
    ["transparent", "tab.inactiveForeground", 0.5]
  ],
  // Tab hover foreground/background
  "tab.hoverBackground": null,
  "tab.unfocusedHoverBackground": [
    ["transparent", "tab.hoverBackground", 0.5],
    ["transparent", "tab.hoverBackground", 0.7]
  ],
  "tab.hoverForeground": null,
  "tab.unfocusedHoverForeground": [
    ["transparent", "tab.hoverForeground", 0.5],
    ["transparent", "tab.hoverForeground", 0.5]
  ],
  // Tab borders
  "tab.border": ["#252526", "#f3f3f3"],
  "tab.lastPinnedBorder": ["tree.indentGuidesStroke", "tree.indentGuidesStroke"],
  "tab.activeBorder": null,
  "tab.unfocusedActiveBorder": [
    ["transparent", "tab.activeBorder", 0.5],
    ["transparent", "tab.activeBorder", 0.7]
  ],
  "tab.activeBorderTop": null,
  "tab.unfocusedActiveBorderTop": [
    ["transparent", "tab.activeBorderTop", 0.5],
    ["transparent", "tab.activeBorderTop", 0.7]
  ],
  "tab.hoverBorder": null,
  "tab.unfocusedHoverBorder": [
    ["transparent", "tab.hoverBorder", 0.5],
    ["transparent", "tab.hoverBorder", 0.7]
  ],
  // Tab modified border
  "tab.activeModifiedBorder": ["#3399cc", "#33aaee"],
  "tab.inactiveModifiedBorder": [
    ["transparent", "tab.activeModifiedBorder", 0.5],
    ["transparent", "tab.activeModifiedBorder", 0.5]
  ],
  "tab.unfocusedActiveModifiedBorder": [
    ["transparent", "tab.activeModifiedBorder", 0.5],
    ["transparent", "tab.activeModifiedBorder", 0.7]
  ],
  "tab.unfocusedInactiveModifiedBorder": [
    ["transparent", "tab.inactiveModifiedBorder", 0.5],
    ["transparent", "tab.inactiveModifiedBorder", 0.5]
  ],
  // Badges (small information labels, for example, search results count)
  "badge.background": ["#4d4d4d", "#c4c4c4"],
  "badge.foreground": ["#ffffff", "#333333"],
  // Buttons
  "button.background": ["#0e639c", "#007acc"],
  "button.foreground": ["#ffffff", "#ffffff"],
  "button.border": "contrastBorder",
  "button.separator": ["transparent", "button.foreground", 0.4],
  "button.hoverBackground": [
    ["lighten", "button.background", 0.2],
    ["darken", "button.background", 0.2]
  ],
  "button.secondaryBackground": ["#3a3d41", "#5f6a79"],
  "button.secondaryForeground": ["#ffffff", "#ffffff"],
  "button.secondaryHoverBackground": [
    ["lighten", "button.secondaryBackground", 0.2],
    ["darken", "button.secondaryBackground", 0.2]
  ],
  // Dropdowns (selects)
  "dropdown.background": ["#3c3c3c", "#ffffff"],
  "dropdown.foreground": ["#f0f0f0", "foreground"],
  "dropdown.border": ["dropdown.background", "#cecece"],
  // Lists
  "list.activeSelectionBackground": ["#04395e", "#0060c0"],
  "list.activeSelectionForeground": "#ffffff",
  // Trees
  "tree.indentGuidesStroke": ["#585858", "#a9a9a9"],
  // Input fields
  "input.background": ["#3c3c3c", "#ffffff"],
  "input.foreground": "foreground",
  "input.placeholderForeground": ["transparent", "foreground", 0.5],
  "inputOption.activeBorder": ["#007acc", "#007acc"],
  "inputOption.hoverBackground": ["#5a5d5e80", "#b8b8b850"],
  "inputOption.activeBackground": [
    ["transparent", "focusBorder", 0.4],
    ["transparent", "focusBorder", 0.2]
  ],
  "inputOption.activeForeground": ["#ffffff", "#000000"],
  "inputValidation.infoBackground": ["#063b49", "#d6ecf2"],
  "inputValidation.infoBorder": ["#007acc", "#007acc"],
  "inputValidation.warningBackground": ["#352a05", "#f6f5d2"],
  "inputValidation.warningBorder": ["#b89500", "#b89500"],
  "inputValidation.errorBackground": ["#5a1d1d", "#f2dede"],
  "inputValidation.errorBorder": ["#be1100", "#be1100"],
  // Keybinding labels
  "keybindingLabel.background": ["#8080802b", "#dddddd66"],
  "keybindingLabel.foreground": ["#cccccc", "#555555"],
  "keybindingLabel.border": ["#33333399", "#cccccc66"],
  "keybindingLabel.bottomBorder": ["#44444499", "#bbbbbb66"],
  // Menu colors
  "menu.foreground": "dropdown.foreground",
  "menu.background": "dropdown.background",
  "menu.selectionForeground": "list.activeSelectionForeground",
  "menu.selectionBackground": "list.activeSelectionBackground",
  "menu.separatorBackground": ["#606060", "#d4d4d4"],
  // Snippet placeholder colors
  "editor.snippetTabstopHighlightBackground": ["#7c7c74c", "#0a326433"],
  "editor.snippetFinalTabstopHighlightBorder": ["#525252", "#0a326480"]
};
function resolveVSCodeWorkbenchColors(colors, themeType) {
  const typeIndex = themeType === "dark" ? 0 : 1;
  const workbenchColors = {
    ...defaultWorkbenchColors,
    ...colors
  };
  const colorsStartedResolving = /* @__PURE__ */ new Set();
  const colorsResolved = /* @__PURE__ */ new Map();
  function applyColorTransform(unresolvedColor) {
    if (unresolvedColor.length === 3) {
      const [type, colorKey, amount] = unresolvedColor;
      const hexColor = resolveColor(colorKey);
      if (hexColor === null)
        return null;
      if (type === "transparent") {
        return multiplyAlpha(hexColor, amount);
      } else if (type === "lighten") {
        return lighten(hexColor, amount);
      } else if (type === "darken") {
        return darken(hexColor, amount);
      }
    }
    if (unresolvedColor.length === 5 && unresolvedColor[0] === "lessProminent") {
      const [, colorKey, backgroundKey, factor, transparency] = unresolvedColor;
      const hexFrom = resolveColor(colorKey);
      if (hexFrom === null)
        return null;
      const hexBackground = resolveColor(backgroundKey);
      if (hexBackground === null)
        return multiplyAlpha(hexFrom, factor * transparency);
      const fromLum = getLuminance(hexFrom);
      const bgLum = getLuminance(hexBackground);
      let combinedFactor = factor ? factor : 0.5;
      if (fromLum < bgLum) {
        combinedFactor *= (bgLum - fromLum) / bgLum;
        const lightened = lighten(hexFrom, combinedFactor);
        return multiplyAlpha(lightened, transparency);
      } else {
        combinedFactor *= (fromLum - bgLum) / fromLum;
        const darkened = darken(hexFrom, combinedFactor);
        return multiplyAlpha(darkened, transparency);
      }
    }
  }
  function resolveColor(unresolvedColor) {
    if (unresolvedColor === null)
      return null;
    const alreadyResolvedColor = colorsResolved.get(unresolvedColor);
    if (alreadyResolvedColor !== void 0)
      return alreadyResolvedColor;
    if (colorsStartedResolving.has(unresolvedColor))
      throw new Error("Circular reference in default colors.");
    colorsStartedResolving.add(unresolvedColor);
    let resolved;
    if (typeof unresolvedColor === "string") {
      if (unresolvedColor.startsWith("#")) {
        resolved = unresolvedColor.toLowerCase();
      } else {
        const referencedColor = workbenchColors[unresolvedColor];
        if (referencedColor !== void 0)
          resolved = resolveColor(referencedColor);
      }
    } else if (Array.isArray(unresolvedColor)) {
      if (unresolvedColor.length === 2) {
        resolved = resolveColor(unresolvedColor[typeIndex]);
      } else {
        resolved = applyColorTransform(unresolvedColor);
      }
    }
    if (resolved === void 0)
      throw new Error(`Invalid color value ${JSON.stringify(unresolvedColor)}, expected a hex color.`);
    colorsResolved.set(unresolvedColor, resolved);
    return resolved;
  }
  const keys = Object.keys(workbenchColors);
  keys.forEach((key) => {
    try {
      workbenchColors[key] = resolveColor(workbenchColors[key]);
    } catch (error) {
      const msg = error instanceof Error ? error.message : error;
      throw new Error(`Failed to resolve theme color for key ${key}: ${msg}`);
    }
  });
  return workbenchColors;
}
function guessThemeTypeFromEditorColors(colors) {
  const bgLuminance = getLuminance(colors?.["editor.background"] || defaultEditorBackgroundColors[0]);
  const fgLuminance = getLuminance(colors?.["editor.foreground"] || defaultEditorForegroundColors[0]);
  return bgLuminance < fgLuminance ? "dark" : "light";
}

// ../../../node_modules/.pnpm/strip-json-comments@5.0.0/node_modules/strip-json-comments/index.js
var singleComment = Symbol("singleComment");
var multiComment = Symbol("multiComment");
var stripWithoutWhitespace = () => "";
var stripWithWhitespace = (string, start, end) => string.slice(start, end).replace(/\S/g, " ");
var isEscaped = (jsonString, quotePosition) => {
  let index = quotePosition - 1;
  let backslashCount = 0;
  while (jsonString[index] === "\\") {
    index -= 1;
    backslashCount += 1;
  }
  return Boolean(backslashCount % 2);
};
function stripJsonComments(jsonString, { whitespace = true, trailingCommas = false } = {}) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof jsonString}\``);
  }
  const strip = whitespace ? stripWithWhitespace : stripWithoutWhitespace;
  let isInsideString = false;
  let isInsideComment = false;
  let offset = 0;
  let buffer = "";
  let result = "";
  let commaIndex = -1;
  for (let index = 0; index < jsonString.length; index++) {
    const currentCharacter = jsonString[index];
    const nextCharacter = jsonString[index + 1];
    if (!isInsideComment && currentCharacter === '"') {
      const escaped = isEscaped(jsonString, index);
      if (!escaped) {
        isInsideString = !isInsideString;
      }
    }
    if (isInsideString) {
      continue;
    }
    if (!isInsideComment && currentCharacter + nextCharacter === "//") {
      buffer += jsonString.slice(offset, index);
      offset = index;
      isInsideComment = singleComment;
      index++;
    } else if (isInsideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
      index++;
      isInsideComment = false;
      buffer += strip(jsonString, offset, index);
      offset = index;
      continue;
    } else if (isInsideComment === singleComment && currentCharacter === "\n") {
      isInsideComment = false;
      buffer += strip(jsonString, offset, index);
      offset = index;
    } else if (!isInsideComment && currentCharacter + nextCharacter === "/*") {
      buffer += jsonString.slice(offset, index);
      offset = index;
      isInsideComment = multiComment;
      index++;
      continue;
    } else if (isInsideComment === multiComment && currentCharacter + nextCharacter === "*/") {
      index++;
      isInsideComment = false;
      buffer += strip(jsonString, offset, index + 1);
      offset = index + 1;
      continue;
    } else if (trailingCommas && !isInsideComment) {
      if (commaIndex !== -1) {
        if (currentCharacter === "}" || currentCharacter === "]") {
          buffer += jsonString.slice(offset, index);
          result += strip(buffer, 0, 1) + buffer.slice(1);
          buffer = "";
          offset = index;
          commaIndex = -1;
        } else if (currentCharacter !== " " && currentCharacter !== "	" && currentCharacter !== "\r" && currentCharacter !== "\n") {
          buffer += jsonString.slice(offset, index);
          offset = index;
          commaIndex = -1;
        }
      } else if (currentCharacter === ",") {
        result += buffer + jsonString.slice(offset, index);
        buffer = "";
        offset = index;
        commaIndex = index;
      }
    }
  }
  return result + buffer + (isInsideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
}

// src/common/theme.ts
var ExpressiveCodeTheme = class _ExpressiveCodeTheme {
  name;
  type;
  colors;
  fg;
  bg;
  semanticHighlighting;
  settings;
  styleOverrides;
  /**
   * Loads the given theme for use with Expressive Code. Supports both Shiki and VS Code themes.
   *
   * You can also pass an existing `ExpressiveCodeTheme` instance to create a copy of it.
   *
   * Note: To save on bundle size, this constructor does not support loading themes
   * bundled with Shiki by name (e.g. `dracula`). Instead, import Shiki's `loadTheme`
   * function yourself, use it to load its bundled theme (e.g. `themes/dracula.json`),
   * and pass the result to this constructor.
   */
  constructor(theme) {
    let themeType = theme.type;
    if (themeType === "css")
      throw new Error('Theme type "css" is not supported.');
    if (themeType !== "dark" && themeType !== "light") {
      themeType = guessThemeTypeFromEditorColors(theme.colors);
    }
    const themeColors = { ...theme.colors };
    for (const key in themeColors) {
      if (typeof themeColors[key] !== "string" || !themeColors[key].trim().length)
        delete themeColors[key];
    }
    this.name = theme.name || themeType;
    this.type = themeType;
    this.colors = resolveVSCodeWorkbenchColors(themeColors, this.type);
    this.fg = theme.fg || this.colors["editor.foreground"];
    this.bg = theme.bg || this.colors["editor.background"];
    this.semanticHighlighting = theme.semanticHighlighting || false;
    const premultiplyTable = [["editorGroupHeader.tabsBackground", "editor.background"]];
    premultiplyTable.forEach(([colorKey, bgKey]) => {
      this.colors[colorKey] = onBackground(this.colors[colorKey], this.colors[bgKey]);
    });
    const themeTokenSettings = theme.tokenColors || theme.settings;
    this.settings = this.parseThemeSettings(themeTokenSettings);
    this.styleOverrides = theme.styleOverrides ?? {};
  }
  /**
   * Applies chromatic adjustments to entire groups of theme colors while keeping their
   * relative lightness and alpha components intact. This can be used to quickly create
   * theme variants that fit the color scheme of any website or brand.
   *
   * Adjustments can either be defined as hue and chroma values in the OKLCH color space
   * (range 0–360 for hue, 0–0.4 for chroma), or these values can be extracted from
   * hex color strings (e.g. `#3b82f6`).
   *
   * You can target predefined groups of theme colors (e.g. `backgrounds`, `accents`)
   * and/or use the `custom` property to define your own groups of theme colors to be adjusted.
   * Each custom group must contain a `themeColorKeys` property with an array of VS Code
   * theme color keys (e.g. `['panel.background', 'panel.border']`) and a `targetHueAndChroma`
   * property that accepts the same adjustment target values as `backgrounds` and `accents`.
   * Custom groups will be applied in the order they are defined.
   *
   * Returns the same `ExpressiveCodeTheme` instance to allow chaining.
   */
  applyHueAndChromaAdjustments(adjustments) {
    const adjustedColors = {};
    const adjustColors = (colors, target) => {
      colors.forEach((color) => {
        if (!this.colors[color])
          return;
        adjustedColors[color] = chromaticRecolor(this.colors[color], target);
      });
    };
    if (adjustments.backgrounds) {
      adjustColors(groupedDefaultWorkbenchColorKeys.backgrounds, adjustments.backgrounds);
    }
    if (adjustments.accents) {
      adjustColors(groupedDefaultWorkbenchColorKeys.accents, adjustments.accents);
    }
    if (adjustments.custom) {
      adjustments.custom.forEach((custom) => {
        adjustColors(custom.themeColorKeys, custom.targetHueAndChroma);
      });
    }
    Object.assign(this.colors, adjustedColors);
    return this;
  }
  /**
   * Processes the theme's syntax highlighting colors to ensure a minimum contrast ratio
   * between foreground and background colors.
   *
   * The default value of 5.5 ensures optimal accessibility with a contrast ratio of 5.5:1.
   *
   * Returns the same `ExpressiveCodeTheme` instance to allow chaining.
   */
  ensureMinSyntaxHighlightingColorContrast(minContrast = 5.5) {
    this.settings.forEach((s) => {
      if (!s.settings.foreground)
        return;
      const newColor = ensureColorContrastOnBackground(s.settings.foreground, this.bg, minContrast);
      if (newColor === s.settings.foreground)
        return;
      s.settings.foreground = newColor;
    });
    return this;
  }
  /**
   * Parses the given theme settings into a properly typed format
   * that can be used by both Expressive Code and Shiki.
   *
   * As theme scopes can be defined as either a comma-separated string, or an array of strings,
   * they will always be converted to their array form to simplify further processing.
   *
   * Also recreates known object properties to prevent accidental mutation
   * of the original settings when copying a theme.
   */
  parseThemeSettings(settings) {
    if (!settings || !Array.isArray(settings))
      return [];
    return settings.map((unknownSetting) => {
      const { name, scope: anyScope, settings: settings2, ...rest } = unknownSetting;
      const scope = Array.isArray(anyScope) ? anyScope.slice() : typeof anyScope === "string" ? anyScope.split(/\s*,\s*/) : void 0;
      return {
        ...name !== void 0 ? { name } : {},
        ...scope !== void 0 ? { scope } : {},
        settings: { ...settings2 },
        ...rest
      };
    });
  }
  /**
   * Attempts to parse the given JSON string as a theme.
   *
   * As some themes follow the JSONC format and may contain comments and trailing commas,
   * this method will attempt to strip them before parsing the result.
   */
  static fromJSONString(json) {
    return new _ExpressiveCodeTheme(JSON.parse(stripJsonComments(json, { trailingCommas: true })));
  }
};

// src/common/plugin-style-settings.ts
var PluginStyleSettings = class {
  defaultValues;
  cssVarExclusions;
  constructor({ defaultValues, cssVarExclusions = [] }) {
    this.defaultValues = defaultValues;
    this.cssVarExclusions = cssVarExclusions;
  }
};

// src/internal/core-styles.ts
var coreStyleSettings = new PluginStyleSettings({
  defaultValues: {
    // Outer container
    borderRadius: "0.3rem",
    borderWidth: "1.5px",
    borderColor: ({ theme }) => theme.colors["titleBar.border"] || lighten(theme.colors["editor.background"], theme.type === "dark" ? 0.5 : -0.15) || "transparent",
    // Code editor content
    codeFontFamily: minifyFontFamily(`ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace`),
    codeFontSize: "0.85rem",
    codeFontWeight: "400",
    codeLineHeight: "1.65",
    codePaddingBlock: "1rem",
    codePaddingInline: "1.35rem",
    codeBackground: ({ theme }) => theme.colors["editor.background"],
    codeForeground: ({ theme }) => theme.colors["editor.foreground"],
    codeSelectionBackground: ({ theme }) => theme.colors["editor.selectionBackground"],
    // UI elements
    uiFontFamily: minifyFontFamily(
      `ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'`
    ),
    uiFontSize: "0.9rem",
    uiFontWeight: "400",
    uiLineHeight: "1.65",
    uiPaddingBlock: "0.25rem",
    uiPaddingInline: "1rem",
    uiSelectionBackground: ({ theme }) => theme.colors["menu.selectionBackground"],
    uiSelectionForeground: ({ theme }) => theme.colors["menu.selectionForeground"],
    // Special colors
    focusBorder: ({ theme }) => theme.colors["focusBorder"],
    scrollbarThumbColor: ({ theme, resolveSetting }) => ensureColorContrastOnBackground(theme.colors["scrollbarSlider.background"], resolveSetting("codeBackground"), 1, 2),
    scrollbarThumbHoverColor: ({ theme, resolveSetting }) => ensureColorContrastOnBackground(theme.colors["scrollbarSlider.hoverBackground"], resolveSetting("codeBackground"), 2.5, 3.5)
  }
});
function getCoreBaseStyles({
  cssVar,
  useStyleReset,
  useThemedScrollbars,
  useThemedSelectionColors
}) {
  const ifThemedScrollbars = (css) => useThemedScrollbars ? css : "";
  const ifThemedSelectionColors = (css) => useThemedSelectionColors ? css : "";
  return `
		font-family: ${cssVar("uiFontFamily")};
		font-size: ${cssVar("uiFontSize")};
		font-weight: ${cssVar("uiFontWeight")};
		line-height: ${cssVar("uiLineHeight")};
		text-size-adjust: none;
		-webkit-text-size-adjust: none;

		*:not(path) {
			${useStyleReset ? "all: revert;" : ""}
			box-sizing: border-box;
		}

		${ifThemedSelectionColors(`::selection {
			background: ${cssVar("uiSelectionBackground")};
			color: ${cssVar("uiSelectionForeground")};
		}`)}

		pre {
			display: flex;
			margin: 0;
			padding: 0;
			border: ${cssVar("borderWidth")} solid ${cssVar("borderColor")};
			border-radius: calc(${cssVar("borderRadius")} + ${cssVar("borderWidth")});
			background: ${cssVar("codeBackground")};

			&:focus-visible {
				outline: 3px solid ${cssVar("focusBorder")};
				outline-offset: -3px;
			}

			& > code {
				all: unset;
				display: block;
				flex: 1 0 100%;

				padding: ${cssVar("codePaddingBlock")} 0;
				color: ${cssVar("codeForeground")};

				font-family: ${cssVar("codeFontFamily")};
				font-size: ${cssVar("codeFontSize")};
				font-weight: ${cssVar("codeFontWeight")};
				line-height: ${cssVar("codeLineHeight")};
			}

			${ifThemedSelectionColors(`::selection {
				background: ${cssVar("codeSelectionBackground")};
				color: inherit;
			}`)}

			/* Show horizontal scrollbar if required */
			overflow-x: auto;

			${ifThemedScrollbars(`
			&::-webkit-scrollbar,
			&::-webkit-scrollbar-track {
				background-color: inherit;
				border-radius: calc(${cssVar("borderRadius")} + ${cssVar("borderWidth")});
				border-top-left-radius: 0;
				border-top-right-radius: 0;
			}
			&::-webkit-scrollbar-thumb {
				background-color: ${cssVar("scrollbarThumbColor")};
				border: 4px solid transparent;
				background-clip: content-box;
				border-radius: 10px;
			}
			&::-webkit-scrollbar-thumb:hover {
				background-color: ${cssVar("scrollbarThumbHoverColor")};
			}
			`)}
		}

		/* Code lines */
		.${codeLineClass} {
			padding-inline: ${cssVar("codePaddingInline")};
			padding-inline-end: calc(2rem + ${cssVar("codePaddingInline")});

			/* RTL support: Code is always LTR */
			direction: ltr;
			unicode-bidi: isolate;
		}

		/* Common style to hide elements from screen readers */
		.sr-only {
			position: absolute;
			width: 1px;
			height: 1px;
			padding: 0;
			margin: -1px;
			overflow: hidden;
			clip: rect(0, 0, 0, 0);
			white-space: nowrap;
			border-width: 0;							
		}
	`;
}
function getCoreThemeStyles(styleVariantIndex) {
  return `
		/* Theme-dependent styles for InlineStyleAnnotation */
		.${codeLineClass} :where(span[style^='--']:not([class])) {
			color: var(--${styleVariantIndex}, inherit);
			font-style: var(--${styleVariantIndex}fs, inherit);
			font-weight: var(--${styleVariantIndex}fw, inherit);
			text-decoration: var(--${styleVariantIndex}td, inherit);
		}
	`;
}
function minifyFontFamily(fontFamily) {
  return fontFamily.split(",").map((font) => font.trim()).join(",");
}

// src/internal/style-resolving.ts
function resolveStyleSettings({
  theme,
  styleVariantIndex,
  plugins,
  styleOverrides
}) {
  const attemptedToResolve = /* @__PURE__ */ new Set();
  const resolvedByPath = /* @__PURE__ */ new Map();
  const resolverArgs = { theme, styleVariantIndex, resolveSetting };
  const unresolvedByPath = getStyleSettingsByPath(coreStyleSettings.defaultValues);
  plugins.forEach((plugin) => {
    if (!plugin.styleSettings)
      return;
    applyStyleSettings(unresolvedByPath, getStyleSettingsByPath(plugin.styleSettings.defaultValues));
  });
  applyStyleSettings(unresolvedByPath, getStyleSettingsByPath(styleOverrides ?? {}));
  applyStyleSettings(unresolvedByPath, getStyleSettingsByPath(theme.styleOverrides ?? {}));
  function resolveSetting(settingPath) {
    let result = resolvedByPath.get(settingPath);
    if (result === void 0 && !resolvedByPath.has(settingPath)) {
      if (attemptedToResolve.has(settingPath))
        throw new Error(`Circular dependency detected while resolving style setting '${settingPath}'`);
      attemptedToResolve.add(settingPath);
      const valueOrResolver = unresolvedByPath.get(settingPath);
      const resolvedDefinition = typeof valueOrResolver === "function" ? valueOrResolver(resolverArgs) : valueOrResolver;
      result = Array.isArray(resolvedDefinition) ? resolvedDefinition[theme.type === "dark" ? 0 : 1] : resolvedDefinition;
      resolvedByPath.set(settingPath, result);
    }
    if (result === void 0)
      throw new Error(
        `Failed to resolve style setting '${settingPath}' for theme '${theme.name}': The resolved value was undefined. This could be caused by your plugins or styleOverrides.`
      );
    return result;
  }
  unresolvedByPath.forEach((_, settingPath) => resolveSetting(settingPath));
  return resolvedByPath;
}
function getCssVarDeclarations({
  resolvedStyleSettings,
  plugins,
  cssVarName
}) {
  const cssVarDeclarations = /* @__PURE__ */ new Map();
  const excludedPaths = /* @__PURE__ */ new Set();
  plugins.forEach((plugin) => {
    plugin.styleSettings?.cssVarExclusions.forEach((path) => excludedPaths.add(path));
  });
  resolvedStyleSettings.forEach((value, path) => {
    if (excludedPaths.has(path))
      return;
    cssVarDeclarations.set(cssVarName(path), value);
  });
  return cssVarDeclarations;
}
function getStyleSettingsByPath(styleSettings) {
  const result = /* @__PURE__ */ new Map();
  for (const [key, value] of Object.entries(styleSettings)) {
    if (typeof value === "object" && !Array.isArray(value)) {
      Object.entries(value).forEach(([subKey, subValue]) => {
        result.set(`${key}.${subKey}`, subValue);
      });
    } else {
      result.set(key, value);
    }
  }
  return result;
}
function applyStyleSettings(target, source) {
  source.forEach((value, path) => value !== void 0 && target.set(path, value));
}

// src/common/style-variants.ts
function resolveStyleVariants({
  themes,
  plugins,
  styleOverrides,
  cssVarName
}) {
  return themes.map((theme, styleVariantIndex) => {
    const resolvedStyleSettings = resolveStyleSettings({ theme, styleVariantIndex, plugins, styleOverrides });
    const cssVarDeclarations = getCssVarDeclarations({ resolvedStyleSettings, plugins, cssVarName });
    return {
      theme,
      resolvedStyleSettings,
      cssVarDeclarations
    };
  });
}

// src/common/logger.ts
var ExpressiveCodeLogger = class {
  label;
  logger;
  constructor(logger = {}) {
    this.label = logger.label ?? "expressive-code";
    this.logger = logger;
  }
  debug(message) {
    if (this.logger.debug) {
      this.logger.debug(message);
    } else {
      console.debug(`[${this.label}] ${message}`);
    }
  }
  info(message) {
    if (this.logger.info) {
      this.logger.info(message);
    } else {
      console.info(`[${this.label}] ${message}`);
    }
  }
  warn(message) {
    if (this.logger.warn) {
      this.logger.warn(message);
    } else {
      console.warn(`[${this.label}] ${message}`);
    }
  }
  error(message) {
    if (this.logger.error) {
      this.logger.error(message);
    } else {
      console.error(`[${this.label}] ${message}`);
    }
  }
};

// src/common/engine.ts
var ExpressiveCodeEngine = class {
  /**
   * Creates a new instance of the Expressive Code engine.
   *
   * To minimize overhead caused by loading plugins, you can create a single instance
   * for your application and keep using it to render all your code blocks.
   */
  constructor(config) {
    const deprecatedConfig = config;
    if (deprecatedConfig.theme && !config.themes) {
      config.themes = Array.isArray(deprecatedConfig.theme) ? deprecatedConfig.theme : [deprecatedConfig.theme];
      delete deprecatedConfig.theme;
    }
    this.themes = Array.isArray(config.themes) ? [...config.themes] : config.themes ? [config.themes] : [new ExpressiveCodeTheme(githubDark), new ExpressiveCodeTheme(githubLight)];
    this.minSyntaxHighlightingColorContrast = config.minSyntaxHighlightingColorContrast ?? 5.5;
    this.useDarkModeMediaQuery = config.useDarkModeMediaQuery ?? (this.themes.length === 2 && this.themes[0].type !== this.themes[1].type);
    this.themeCssRoot = config.themeCssRoot ?? ":root";
    this.themeCssSelector = config.themeCssSelector ?? ((theme) => `[data-theme='${theme.name}']`);
    this.cascadeLayer = config.cascadeLayer ?? "";
    this.useStyleReset = config.useStyleReset ?? true;
    this.customizeTheme = config.customizeTheme;
    this.useThemedScrollbars = config.useThemedScrollbars ?? true;
    this.useThemedSelectionColors = config.useThemedSelectionColors ?? false;
    this.styleOverrides = { ...config.styleOverrides };
    this.defaultLocale = config.defaultLocale || "en-US";
    this.plugins = config.plugins?.flat() || [];
    this.logger = new ExpressiveCodeLogger(config.logger);
    this.themes = this.themes.map((theme) => {
      if (this.customizeTheme) {
        theme = this.customizeTheme(theme) ?? theme;
      }
      if (this.minSyntaxHighlightingColorContrast > 0) {
        theme.ensureMinSyntaxHighlightingColorContrast(this.minSyntaxHighlightingColorContrast);
      }
      return theme;
    });
    this.styleVariants = resolveStyleVariants({
      themes: this.themes,
      styleOverrides: this.styleOverrides,
      plugins: this.plugins,
      cssVarName: getCssVarName
    });
  }
  /**
   * Renders the given code block(s) and returns the rendered group & block ASTs,
   * the rendered code block contents after all transformations have been applied,
   * and a set of non-global CSS styles required by the rendered code blocks.
   *
   * In Expressive Code, all processing of your code blocks and their metadata
   * is performed by plugins. To render markup around lines or inline ranges of characters,
   * the `render` method calls the hook functions registered by all added plugins.
   *
   * @param input
   * The code block(s) to render. Can either be an `ExpressiveCodeBlockOptions` object
   * containing the properties required to create a new `ExpressiveCodeBlock` internally,
   * an existing `ExpressiveCodeBlock`, or an array containing any combination of these.
   *
   * @param options
   * Optional configuration options for the rendering process.
   */
  async render(input, options) {
    return await renderGroup({
      input,
      options,
      defaultLocale: this.defaultLocale,
      config: {
        ...this
      },
      plugins: this.plugins,
      // Also pass resolved style variants in case plugins need them
      ...this.getResolverContext()
    });
  }
  /**
   * Returns a string containing all CSS styles that should be added to every page
   * using Expressive Code. These styles are static base styles which do not depend
   * on the configured theme(s).
   *
   * The calling code must take care of actually adding the returned styles to the page.
   *
   * Please note that the styles contain references to CSS variables, which must also
   * be added to the page. These can be obtained by calling {@link getThemeStyles}.
   */
  async getBaseStyles() {
    const pluginStyles = [];
    const resolverContext = this.getResolverContext();
    pluginStyles.push({
      pluginName: "core",
      styles: getCoreBaseStyles({
        ...resolverContext,
        useStyleReset: this.useStyleReset,
        useThemedScrollbars: this.useThemedScrollbars,
        useThemedSelectionColors: this.useThemedSelectionColors
      })
    });
    for (const plugin of this.plugins) {
      if (!plugin.baseStyles)
        continue;
      const resolvedStyles = typeof plugin.baseStyles === "function" ? await plugin.baseStyles(resolverContext) : plugin.baseStyles;
      if (!resolvedStyles)
        continue;
      pluginStyles.push({
        pluginName: plugin.name,
        styles: resolvedStyles
      });
    }
    const processedStyles = await processPluginStyles(pluginStyles);
    return wrapInCascadeLayer([...processedStyles].join(""), this.cascadeLayer);
  }
  /**
   * Returns a string containing theme-dependent styles that should be added to every page
   * using Expressive Code. These styles contain CSS variable declarations that are generated
   * automatically based on the configured {@link ExpressiveCodeEngineConfig.themes themes},
   * {@link ExpressiveCodeEngineConfig.useDarkModeMediaQuery useDarkModeMediaQuery} and
   * {@link ExpressiveCodeEngineConfig.themeCssSelector themeCssSelector} config options.
   *
   * The first theme defined in the `themes` option is considered the "base theme",
   * for which a full set of CSS variables is declared and scoped to the selector
   * defined by the `themeCssRoot` option (defaults to `:root`).
   *
   * For all alternate themes, a differential set of CSS variables is declared for cases where
   * their values differ from the base theme, and scoped to theme-specific selectors that are
   * generated by combining `themeCssRoot` with the theme selector specified by this option.
   *
   * The calling code must take care of actually adding the returned styles to the page.
   *
   * Please note that these styles must be added to the page together with the base styles
   * returned by {@link getBaseStyles}.
   */
  async getThemeStyles() {
    const themeStyles = [];
    const renderDeclarations = (declarations) => [...declarations].map(([varName, varValue]) => `${varName}:${varValue}`).join(";");
    const { cssVarDeclarations: baseVars, theme: baseTheme } = this.styleVariants[0];
    const baseThemeSelector = this.themeCssSelector && this.themeCssSelector(baseTheme, { styleVariants: this.styleVariants });
    const notBaseThemeSelector = baseThemeSelector ? `:not(${baseThemeSelector})` : "";
    const baseThemeBlockInsideAlternateThemeRoot = notBaseThemeSelector && `${this.themeCssRoot}${notBaseThemeSelector} &${baseThemeSelector}`;
    const baseVarSelectors = [
      // Root selector without any specific theme selectors
      this.themeCssRoot,
      // Code blocks with base theme selector inside root with non-base theme selector
      baseThemeBlockInsideAlternateThemeRoot
    ].filter((selector) => selector).join(",");
    const baseThemeStyleSelectors = [
      // Code blocks with no specific theme selector
      "&",
      // Code blocks with base theme selector inside root with non-base theme selector
      baseThemeBlockInsideAlternateThemeRoot
    ].filter((selector) => selector).join(",");
    themeStyles.push(
      await scopeAndMinifyNestedCss(`
				${baseVarSelectors} {
					${renderDeclarations(baseVars)}
				}
				${baseThemeStyleSelectors} {
					${getCoreThemeStyles(0)}
				}
			`)
    );
    const alternateVariants = [];
    for (let styleVariantIndex = 1; styleVariantIndex < this.styleVariants.length; styleVariantIndex++) {
      const styleVariant = this.styleVariants[styleVariantIndex];
      const diffVars = /* @__PURE__ */ new Map();
      styleVariant.cssVarDeclarations.forEach((varValue, varName) => {
        if (baseVars.get(varName) !== varValue) {
          diffVars.set(varName, varValue);
        }
      });
      alternateVariants.push({
        theme: styleVariant.theme,
        cssVars: renderDeclarations(diffVars),
        coreStyles: getCoreThemeStyles(styleVariantIndex)
      });
    }
    if (this.useDarkModeMediaQuery) {
      const baseTheme2 = this.styleVariants[0].theme;
      const altType = baseTheme2.type === "dark" ? "light" : "dark";
      const firstAltVariant = alternateVariants.find((variant) => variant.theme.type === altType);
      if (!firstAltVariant)
        throw new Error(
          [
            `The config option "useDarkModeMediaQuery: true" requires at least`,
            `one dark and one light theme, but the following themes were given:`,
            this.themes.map((theme) => `${theme.name} (${theme.type})`).join(", ")
          ].join(" ")
        );
      const darkModeMediaQuery = await scopeAndMinifyNestedCss(`
				@media (prefers-color-scheme: ${altType}) {
					${this.themeCssRoot}${notBaseThemeSelector} {
						${firstAltVariant.cssVars}
					}
					${this.themeCssRoot}${notBaseThemeSelector} & {
						${firstAltVariant.coreStyles}
					}
				}
			`);
      themeStyles.push(darkModeMediaQuery);
    }
    if (this.themeCssSelector !== false) {
      for (const { theme, cssVars, coreStyles } of alternateVariants) {
        const themeSelector = this.themeCssSelector && this.themeCssSelector(theme, { styleVariants: this.styleVariants });
        if (!themeSelector)
          continue;
        themeStyles.push(
          await scopeAndMinifyNestedCss(`
						${this.themeCssRoot}${themeSelector} &${notBaseThemeSelector}, &${themeSelector} {
							${cssVars};
							${coreStyles}
						}
					`)
        );
      }
    }
    return wrapInCascadeLayer(themeStyles.join(""), this.cascadeLayer);
  }
  /**
   * Returns an array of JavaScript modules (pure core without any wrapping `script` tags)
   * that should be added to every page containing code blocks.
   *
   * The contents are collected from the `jsModules` property of all registered plugins.
   * Any duplicates are removed.
   *
   * The calling code must take care of actually adding the collected scripts to the page.
   * For example, it could create site-wide JavaScript files from the returned modules
   * and refer to them in a script tag with `type="module"`, or it could insert them
   * into inline `<script type="module">` elements.
   */
  async getJsModules() {
    const jsModules = /* @__PURE__ */ new Set();
    for (const plugin of this.plugins) {
      const pluginModules = typeof plugin.jsModules === "function" ? await plugin.jsModules(this.getResolverContext()) : plugin.jsModules;
      pluginModules?.forEach((moduleCode) => {
        moduleCode = moduleCode.trim();
        if (moduleCode)
          jsModules.add(moduleCode);
      });
    }
    return [...jsModules];
  }
  cssVar(styleSetting, fallbackValue) {
    return `var(${getCssVarName(styleSetting)}${fallbackValue ? `, ${fallbackValue}` : ""})`;
  }
  getResolverContext() {
    return {
      cssVar: (styleSetting, fallbackValue) => this.cssVar(styleSetting, fallbackValue),
      cssVarName: getCssVarName,
      styleVariants: this.styleVariants
    };
  }
  themes;
  minSyntaxHighlightingColorContrast;
  useDarkModeMediaQuery;
  themeCssRoot;
  themeCssSelector;
  cascadeLayer;
  useStyleReset;
  customizeTheme;
  useThemedScrollbars;
  useThemedSelectionColors;
  styleOverrides;
  styleVariants;
  defaultLocale;
  plugins;
  logger;
};

// src/common/plugin-data.ts
var AttachedPluginData = class {
  dataStorage = /* @__PURE__ */ new WeakMap();
  getInitialValueFn;
  constructor(getInitialValueFn) {
    this.getInitialValueFn = getInitialValueFn;
  }
  getOrCreateFor(target) {
    let data = this.dataStorage.get(target);
    if (data === void 0) {
      data = this.getInitialValueFn();
      this.dataStorage.set(target, data);
    }
    return data;
  }
  setFor(target, data) {
    this.dataStorage.set(target, data);
  }
};

// src/common/plugin-texts.ts
var PluginTexts = class {
  defaultTexts;
  localizedTexts = /* @__PURE__ */ new Map();
  overridesByLocale = /* @__PURE__ */ new Map();
  constructor(defaultTexts) {
    this.defaultTexts = defaultTexts;
  }
  /**
   * Adds localized texts for a specific locale. You must provide a full set of localized texts
   * for the given locale.
   *
   * It is recommended to use two-letter language codes (e.g. `de`, `fr`, `es`) without region
   * codes to make your localized texts available to all users speaking the same language.
   * Region codes should only be added if regional differences must be taken into account.
   *
   * Plugin authors can use this to provide localized versions of their texts.
   * Users can also call this function to provide their own localizations.
   *
   * If you only want to customize a few texts of an existing localization,
   * have a look at `overrideTexts` instead.
   */
  addLocale(locale, localizedTexts) {
    locale = this.parseLocale(locale).locale;
    this.localizedTexts.set(locale, localizedTexts);
  }
  /**
   * Allows you to override any defined texts. This is useful if you want to customize a few
   * selected texts without having to provide a full set of localized texts.
   *
   * You can either override texts for a specific `locale`, or override the default texts
   * by setting `locale` to `undefined`.
   *
   * It is recommended to use two-letter language codes (e.g. `de`, `fr`, `es`) without region
   * codes to apply your overrides to all users speaking the same language.
   * Region codes should only be added if regional differences must be taken into account.
   */
  overrideTexts(locale, localeTextOverrides) {
    locale = locale && this.parseLocale(locale).locale;
    const localeOverrides = this.overridesByLocale.get(locale) || this.overridesByLocale.set(locale, {}).get(locale);
    Object.assign(localeOverrides, localeTextOverrides);
  }
  /**
   * Returns the best matching texts for the requested locale,
   * taking any available localized texts and overrides into account.
   *
   * Example for locale `de-DE`:
   * - If localized texts for `de-DE` are available, these will be returned.
   * - If `de-DE` is not available, but `de` is, these will be returned.
   * - As the final fallback, the default texts will be returned.
   */
  get(locale) {
    const { acceptedLocales } = this.parseLocale(locale);
    const localizedTexts = this.getLocalizedTexts(acceptedLocales);
    return this.applyOverrides(localizedTexts, acceptedLocales);
  }
  parseLocale(locale) {
    const parts = locale.trim().toLowerCase().split(/[-_]/);
    const language = parts[0];
    const region = parts[1];
    const normalizedLocale = region ? `${language}-${region}` : language;
    const acceptedLocales = [];
    acceptedLocales.push(language);
    if (region)
      acceptedLocales.push(normalizedLocale);
    return {
      language,
      region,
      locale: normalizedLocale,
      acceptedLocales
    };
  }
  getLocalizedTexts(acceptedLocales) {
    for (const acceptedLocale of acceptedLocales) {
      const localizedTexts = this.localizedTexts.get(acceptedLocale);
      if (localizedTexts) {
        return localizedTexts;
      }
    }
    return this.defaultTexts;
  }
  applyOverrides(texts, acceptedLocales) {
    const result = { ...texts };
    const overrides = [...acceptedLocales, void 0].map((locale) => this.overridesByLocale.get(locale)).filter((x) => x);
    if (overrides.length) {
      const keys = Object.keys(texts);
      keys.forEach((key) => {
        for (const override of overrides) {
          const overrideValue = override?.[key];
          if (overrideValue) {
            result[key] = overrideValue;
            return;
          }
        }
      });
    }
    return result;
  }
};

// src/helpers/i18n.ts
function formatTemplate(template, variables) {
  const getReplacement = (varName, ...choices) => {
    const value = variables[varName];
    if (value === void 0)
      throw new Error(`Unknown variable name "${varName}" found in string template "${template}". Available variables: ${JSON.stringify(Object.keys(variables))}`);
    if (!choices.length)
      return value.toString();
    const parsedChoices = choices.map((choice) => {
      const condition = choice.match(/^\s*(<|>|)\s*(-?[0-9.]+?)\s*=\s?/);
      if (!condition)
        return { text: choice.replace(/^\s/, "") };
      const [fullMatch, operator, conditionValue] = condition;
      const number = Number.parseFloat(conditionValue);
      if (isNaN(number))
        throw new Error(`Expected condition value "${conditionValue}" to be a number in string template "${template}".`);
      if (typeof value !== "number")
        throw new Error(
          `Condition "${operator}${conditionValue}" in string template "${template}" requires variable "${varName}" to be a number, but it's ${JSON.stringify(value)}.`
        );
      return {
        condition: {
          operator: operator || "=",
          number
        },
        text: choice.slice(fullMatch.length)
      };
    });
    const catchAllCount = parsedChoices.filter((choice) => !choice.condition).length;
    if (catchAllCount !== 1)
      throw new Error(`Expected exactly 1 catch-all choice for variable "${varName}", but found ${catchAllCount} in string template "${template}".`);
    for (const { condition, text } of parsedChoices) {
      if (!condition)
        return text;
      if (typeof value !== "number")
        continue;
      const conditionIsMatching = (
        // Less than
        condition.operator === "<" && value < condition.number || // Greater than
        condition.operator === ">" && value > condition.number || // Equals
        condition.operator === "=" && value === condition.number
      );
      if (conditionIsMatching)
        return text;
    }
    return "";
  };
  let result = template;
  result = result.replace(/(?<!\\)\\{/g, "\f(").replace(/(?<!\\)\\}/g, "\f)");
  result = result.replace(/\\(\\[{}])/g, "$1");
  const innermostPlaceholderRegex = /\{([^{]*?)\}/g;
  let keepGoing = true;
  while (keepGoing) {
    keepGoing = false;
    result = result.replace(innermostPlaceholderRegex, (match, contents) => {
      keepGoing = true;
      const [varName, ...choices] = contents.split(";");
      return getReplacement(varName, ...choices).replace(/{/g, "\f(").replace(/}/g, "\f)");
    });
  }
  result = result.replace(/\f\(/g, "{").replace(/\f\)/g, "}");
  return result;
}

// ../../../node_modules/.pnpm/djb2a@2.0.0/node_modules/djb2a/index.js
var MAGIC_CONSTANT = 5381;
function djb2a(string) {
  let hash = MAGIC_CONSTANT;
  for (let index = 0; index < string.length; index++) {
    hash = (hash << 5) + hash ^ string.charCodeAt(index);
  }
  return hash >>> 0;
}

// src/helpers/objects.ts
function stableStringify(obj, options = {}) {
  const { includeFunctionContents = false } = options;
  const visited = /* @__PURE__ */ new WeakSet();
  const toJson = (value) => {
    if (typeof value === "object" && value !== null) {
      if (visited.has(value)) {
        return "[Circular]";
      }
      visited.add(value);
      let result;
      if (Array.isArray(value)) {
        result = value.map(toJson);
      } else {
        const objValue = value;
        const sortedKeys = Object.keys(objValue).sort();
        const sortedObj = {};
        for (const key of sortedKeys) {
          sortedObj[key] = toJson(objValue[key]);
        }
        result = sortedObj;
      }
      visited.delete(value);
      return result;
    }
    if (typeof value === "function") {
      return includeFunctionContents ? value.toString() : "[Function]";
    }
    return value;
  };
  if (obj === void 0)
    return "undefined";
  return JSON.stringify(toJson(obj));
}
function getStableObjectHash(obj, options = {}) {
  const { includeFunctionContents = false, hashLength = 5 } = options;
  const numericHash = djb2a(stableStringify(obj, { includeFunctionContents }));
  const padding = "0".repeat(hashLength);
  return (padding + numericHash.toString(36)).slice(-hashLength);
}

// src/helpers/string-processing.ts
function replaceDelimitedValues(input, replacer, syntax = {
  valueDelimiters: ['"', "'"],
  keyValueSeparator: "="
}) {
  let result = input;
  const valueDelimiterPairs = syntax.valueDelimiters.map((valueDelimiter) => {
    const parts = valueDelimiter.split("...");
    const isPair = parts.length === 2;
    return {
      valueStartDelimiter: isPair ? parts[0] : valueDelimiter,
      valueEndDelimiter: isPair ? parts[1] : valueDelimiter
    };
  });
  const regExpParts = valueDelimiterPairs.map(({ valueStartDelimiter, valueEndDelimiter }) => {
    const part = [
      // Whitespace or start of string
      `(?:\\s|^)`,
      // Optional group for key name and key/value separator
      [
        // Start of non-capturing optional group
        `(?:`,
        // Key name (captured)
        `([^\\s"'${escapeRegExp(syntax.keyValueSeparator.replace(/-/g, "\\-"))}]+)`,
        // Optional whitespace
        `\\s*`,
        // Key/value separator (e.g. `=`)
        escapeRegExp(syntax.keyValueSeparator),
        // Optional whitespace
        `\\s*`,
        // End of non-capturing optional group
        `)?`
      ],
      // Value start delimiter
      escapeRegExp(valueStartDelimiter),
      // Value string (captured, can be an empty string),
      // consisting of any of the following parts:
      // - any character that is not a backslash
      // - a backslash followed by any character
      `((?:[^\\\\]|\\\\.)*?)`,
      // Value end delimiter that is not escaped by a preceding `\`
      `${escapeRegExp(valueEndDelimiter)}`,
      // Whitespace or end of string
      `(?=\\s|$)`
    ];
    return part.flat().join("");
  });
  const regExp = new RegExp(regExpParts.join("|"), "g");
  result = result.replace(
    regExp,
    // Process the current match along with its capture group string contents
    // by calling the given replacer function and returning its result
    (fullMatch, ...keyValuePairs) => {
      const firstCaptureGroupIndex = keyValuePairs.findIndex((value2) => value2 !== void 0);
      const delimiterPairIdx = Math.floor(firstCaptureGroupIndex / 2);
      const { valueStartDelimiter, valueEndDelimiter } = valueDelimiterPairs[delimiterPairIdx];
      const [key, escapedValue] = keyValuePairs.slice(delimiterPairIdx * 2, delimiterPairIdx * 2 + 2);
      const escapedBackslashOrValueEndDelimiter = new RegExp(`\\\\(\\\\|${escapeRegExp(valueEndDelimiter)})`, "g");
      const value = escapedValue.replace(escapedBackslashOrValueEndDelimiter, "$1");
      return replacer({ fullMatch, key, value, valueStartDelimiter, valueEndDelimiter });
    }
  );
  return result;
}
function getGroupIndicesFromRegExpMatch(match) {
  let groupIndices = match.indices;
  if (groupIndices?.length)
    return groupIndices;
  const fullMatchIndex = match.index;
  groupIndices = match.map((groupValue) => {
    const groupIndex = groupValue ? match[0].indexOf(groupValue) : -1;
    if (groupIndex === -1)
      return null;
    const groupStart = fullMatchIndex + groupIndex;
    const groupEnd = groupStart + groupValue.length;
    return [groupStart, groupEnd];
  });
  return groupIndices;
}
function kebabCase(str) {
  return str.trim().replace(/([a-z])([A-Z])/g, "$1-$2").replace(/([a-zA-Z])([0-9])/g, "$1-$2").replace(/([0-9])([a-zA-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z])/g, "$1-$2").replace(/[^a-zA-Z0-9]+/g, "-").replace(/^-+|-+$/g, "").toLowerCase();
}
export {
  AnnotationRenderPhaseOrder,
  AttachedPluginData,
  ExpressiveCodeAnnotation,
  ExpressiveCodeBlock,
  ExpressiveCodeEngine,
  ExpressiveCodeLine,
  ExpressiveCodeTheme,
  InlineStyleAnnotation,
  PluginStyleSettings,
  PluginTexts,
  addClassName,
  annotationSortFn,
  changeAlphaToReachColorContrast,
  changeLuminanceToReachColorContrast,
  chromaticRecolor,
  codeLineClass,
  cssVarReplacements,
  darken,
  ensureColorContrastOnBackground,
  formatTemplate,
  getClassNames,
  getColorContrast,
  getColorContrastOnBackground,
  getCssVarName,
  getGroupIndicesFromRegExpMatch,
  getLuminance,
  getStableObjectHash,
  kebabCase,
  lighten,
  mix,
  multiplyAlpha,
  onBackground,
  replaceDelimitedValues,
  resolveStyleVariants,
  runHooks,
  setAlpha,
  setLuminance,
  setProperty,
  stableStringify,
  toHexColor,
  toRgbaString,
  validateExpressiveCodeAnnotation
};
//# sourceMappingURL=index.js.map