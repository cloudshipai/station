package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"station/pkg/faker"

	"github.com/spf13/cobra"
	_ "modernc.org/sqlite"
)

var (
	sessionOutputFormat string
	sessionLimit        int
)

var fakerSessionsCmd = &cobra.Command{
	Use:   "sessions",
	Short: "Manage faker sessions",
	Long: `Manage faker sessions and view session history.

Sessions track all tool calls made through faker proxies, including:
- Tool names and arguments
- Responses generated by AI enrichment
- Timestamps and operation types (read/write)
- Session duration and statistics

Use these commands to inspect faker behavior, debug simulations,
and analyze tool usage patterns.`,
}

var fakerSessionsListCmd = &cobra.Command{
	Use:   "list",
	Short: "List all faker sessions",
	Long: `List all faker sessions with basic information.

Shows session ID, creation time, duration, and number of tool calls.
Sessions are ordered by creation time (newest first).

Examples:
  # List all sessions
  stn faker sessions list

  # Limit to 10 most recent
  stn faker sessions list --limit 10`,
	RunE: runFakerSessionsList,
}

var fakerSessionViewCmd = &cobra.Command{
	Use:   "view <session-id>",
	Short: "View detailed session information",
	Long: `View complete session details including all tool calls.

Shows:
- Session metadata (ID, instruction, timestamps)
- All tool calls in chronological order
- Tool arguments and responses (formatted JSON)
- Session statistics

Examples:
  # View session details
  stn faker session view faker-session-1731098065

  # Export as JSON
  stn faker session view faker-session-1731098065 --format json`,
	Args: cobra.ExactArgs(1),
	RunE: runFakerSessionView,
}

var fakerSessionDeleteCmd = &cobra.Command{
	Use:   "delete <session-id>",
	Short: "Delete a faker session",
	Long: `Delete a specific faker session and all its tool call events.

This permanently removes the session from the database.

Examples:
  # Delete a session
  stn faker session delete faker-session-1731098065`,
	Args: cobra.ExactArgs(1),
	RunE: runFakerSessionDelete,
}

var fakerSessionsClearCmd = &cobra.Command{
	Use:   "clear",
	Short: "Clear all faker sessions",
	Long: `Delete all faker sessions and their tool call events.

This permanently removes all session data from the database.
Use with caution!

Examples:
  # Clear all sessions
  stn faker sessions clear`,
	RunE: runFakerSessionsClear,
}

var fakerMetricsCmd = &cobra.Command{
	Use:   "metrics",
	Short: "Show faker metrics and statistics",
	Long: `Display aggregated metrics across all faker sessions.

Shows:
- Total sessions and session counts by time period
- Total tool calls and average calls per session
- Most frequently called tools
- Recent sessions

Examples:
  # Show metrics
  stn faker metrics`,
	RunE: runFakerMetrics,
}

var fakerSessionReplayCmd = &cobra.Command{
	Use:   "replay <session-id>",
	Short: "Export session for replay and debugging",
	Long: `Export a faker session in replayable format with all tool calls and timing.

This command exports the session with:
- All tool calls in chronological order with sequence numbers
- Tool arguments and responses (full JSON)
- Timing information (elapsed milliseconds from session start)
- Session statistics and metadata

The exported JSON can be used to:
- Debug agent behavior and understand what data agents received
- Replay scenarios to test agent improvements
- Share realistic test scenarios as reproducible test cases
- Analyze faker simulation quality

Examples:
  # Export session for replay
  stn faker session replay faker-session-1731098065

  # Save to file for sharing
  stn faker session replay faker-session-1731098065 > scenario.json`,
	Args: cobra.ExactArgs(1),
	RunE: runFakerSessionReplay,
}

func init() {
	// Add subcommands to faker command
	fakerCmd.AddCommand(fakerSessionsCmd)
	fakerCmd.AddCommand(fakerMetricsCmd)

	// Add session management commands
	fakerSessionsCmd.AddCommand(fakerSessionsListCmd)
	fakerSessionsCmd.AddCommand(fakerSessionViewCmd)
	fakerSessionsCmd.AddCommand(fakerSessionDeleteCmd)
	fakerSessionsCmd.AddCommand(fakerSessionsClearCmd)
	fakerSessionsCmd.AddCommand(fakerSessionReplayCmd)

	// Add flags
	fakerSessionsListCmd.Flags().IntVar(&sessionLimit, "limit", 0, "Limit number of sessions to show")
	fakerSessionViewCmd.Flags().StringVar(&sessionOutputFormat, "format", "text", "Output format (text, json)")
}

func getDB() (*sql.DB, error) {
	// Get config directory (Station uses XDG_CONFIG_HOME/station by default)
	configDir := getConfigDir()
	dbPath := filepath.Join(configDir, "station.db")

	db, err := sql.Open("sqlite", dbPath)
	if err != nil {
		return nil, fmt.Errorf("failed to open database: %w", err)
	}

	return db, nil
}

func getConfigDir() string {
	// Check if config flag was set
	if cfgFile != "" {
		return filepath.Dir(cfgFile)
	}

	// Default to XDG_CONFIG_HOME/station or ~/.config/station
	configHome := os.Getenv("XDG_CONFIG_HOME")
	if configHome == "" {
		homeDir, _ := os.UserHomeDir()
		configHome = filepath.Join(homeDir, ".config")
	}
	return filepath.Join(configHome, "station")
}

func runFakerSessionsList(cmd *cobra.Command, args []string) error {
	db, err := getDB()
	if err != nil {
		return fmt.Errorf("failed to get database: %w", err)
	}
	defer db.Close()

	svc := faker.NewSessionService(db)
	sessions, err := svc.ListSessions(context.Background())
	if err != nil {
		return fmt.Errorf("failed to list sessions: %w", err)
	}

	// Apply limit if specified
	if sessionLimit > 0 && len(sessions) > sessionLimit {
		sessions = sessions[:sessionLimit]
	}

	if len(sessions) == 0 {
		fmt.Println("No faker sessions found.")
		fmt.Println("\nFaker sessions are created automatically when you run agents that use faker-wrapped MCP servers.")
		return nil
	}

	// Print header
	fmt.Println("\nFAKER SESSIONS")
	fmt.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	fmt.Printf("%-40s %-20s %-10s %s\n", "SESSION ID", "STARTED", "DURATION", "TOOLS")
	fmt.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

	// Print sessions
	for _, sess := range sessions {
		sessionID := sess.ID
		if len(sessionID) > 38 {
			sessionID = sessionID[:35] + "..."
		}

		fmt.Printf("%-40s %-20s %-10s %d\n",
			sessionID,
			sess.CreatedAt.Format("2006-01-02 15:04:05"),
			formatDuration(sess.Duration),
			sess.ToolCallCount,
		)
	}

	fmt.Printf("\nTotal: %d sessions\n", len(sessions))
	fmt.Println("\nUse 'stn faker session view <session-id>' to see detailed information.")

	return nil
}

func runFakerSessionView(cmd *cobra.Command, args []string) error {
	sessionID := args[0]

	db, err := getDB()
	if err != nil {
		return fmt.Errorf("failed to get database: %w", err)
	}
	defer db.Close()

	svc := faker.NewSessionService(db)
	details, err := svc.GetSessionDetails(context.Background(), sessionID)
	if err != nil {
		return fmt.Errorf("failed to get session details: %w", err)
	}

	if sessionOutputFormat == "json" {
		jsonData, err := json.MarshalIndent(details, "", "  ")
		if err != nil {
			return fmt.Errorf("failed to marshal JSON: %w", err)
		}
		fmt.Println(string(jsonData))
		return nil
	}

	// Text format
	fmt.Printf("\nSession: %s\n", details.Session.ID)
	fmt.Printf("Started: %s\n", details.Session.CreatedAt.Format("2006-01-02 15:04:05 MST"))
	fmt.Printf("Updated: %s\n", details.Session.UpdatedAt.Format("2006-01-02 15:04:05 MST"))
	fmt.Printf("Duration: %s\n\n", formatDuration(details.Stats.Duration))

	fmt.Println("AI Instruction:")
	fmt.Printf("  \"%s\"\n\n", truncateString(details.Session.Instruction, 200))

	fmt.Printf("Tool Calls (%d):\n", len(details.ToolCalls))
	fmt.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

	for i, tc := range details.ToolCalls {
		fmt.Printf("%d. %s (%s) - %s\n",
			i+1,
			tc.ToolName,
			tc.Timestamp.Format("15:04:05"),
			tc.OperationType,
		)
		fmt.Println()

		// Print arguments
		fmt.Println("   Input:")
		argsJSON, _ := json.MarshalIndent(tc.Arguments, "   ", "  ")
		fmt.Printf("   %s\n\n", string(argsJSON))

		// Print response
		fmt.Println("   Output:")
		responseJSON, _ := json.MarshalIndent(tc.Response, "   ", "  ")
		outputStr := string(responseJSON)
		if len(outputStr) > 500 {
			outputStr = outputStr[:500] + "\n   ... (truncated, use --format json for full output)"
		}
		fmt.Printf("   %s\n\n", outputStr)
	}

	// Print statistics
	fmt.Println("Statistics:")
	fmt.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
	fmt.Printf("  Total Tool Calls: %d\n", details.Stats.TotalToolCalls)
	fmt.Printf("  Read Operations:  %d\n", details.Stats.ReadCalls)
	fmt.Printf("  Write Operations: %d\n", details.Stats.WriteCalls)
	fmt.Printf("  Unique Tools:     %d\n", details.Stats.UniqueTools)
	fmt.Printf("  Duration:         %s\n", formatDuration(details.Stats.Duration))
	fmt.Println()

	return nil
}

func runFakerSessionDelete(cmd *cobra.Command, args []string) error {
	sessionID := args[0]

	db, err := getDB()
	if err != nil {
		return fmt.Errorf("failed to get database: %w", err)
	}
	defer db.Close()

	svc := faker.NewSessionService(db)
	err = svc.DeleteSession(context.Background(), sessionID)
	if err != nil {
		return fmt.Errorf("failed to delete session: %w", err)
	}

	fmt.Printf("âœ“ Session deleted: %s\n", sessionID)
	return nil
}

func runFakerSessionsClear(cmd *cobra.Command, args []string) error {
	db, err := getDB()
	if err != nil {
		return fmt.Errorf("failed to get database: %w", err)
	}
	defer db.Close()

	svc := faker.NewSessionService(db)

	// Get count before clearing
	count, err := svc.GetSessionCount(context.Background())
	if err != nil {
		return fmt.Errorf("failed to get session count: %w", err)
	}

	if count == 0 {
		fmt.Println("No sessions to clear.")
		return nil
	}

	// Confirm with user
	fmt.Printf("âš ï¸  This will delete %d session(s) and all their tool call events.\n", count)
	fmt.Print("Are you sure? (yes/no): ")

	var response string
	fmt.Scanln(&response)

	if strings.ToLower(response) != "yes" {
		fmt.Println("Cancelled.")
		return nil
	}

	// Clear all sessions
	deleted, err := svc.ClearAllSessions(context.Background())
	if err != nil {
		return fmt.Errorf("failed to clear sessions: %w", err)
	}

	fmt.Printf("âœ“ Cleared %d session(s)\n", deleted)
	return nil
}

func runFakerMetrics(cmd *cobra.Command, args []string) error {
	db, err := getDB()
	if err != nil {
		return fmt.Errorf("failed to get database: %w", err)
	}
	defer db.Close()

	svc := faker.NewSessionService(db)
	metrics, err := svc.GetMetrics(context.Background())
	if err != nil {
		return fmt.Errorf("failed to get metrics: %w", err)
	}

	if metrics.TotalSessions == 0 {
		fmt.Println("No faker sessions found.")
		fmt.Println("\nFaker sessions are created automatically when you run agents that use faker-wrapped MCP servers.")
		return nil
	}

	// Print metrics
	fmt.Println("\nFAKER METRICS")
	fmt.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

	fmt.Println("\nðŸ“Š Session Statistics")
	fmt.Printf("  Total Sessions:     %d\n", metrics.TotalSessions)
	fmt.Printf("  Sessions (Last 24h): %d\n", metrics.SessionsLast24h)
	fmt.Printf("  Sessions (Last 7d):  %d\n", metrics.SessionsLast7d)

	fmt.Println("\nðŸ› ï¸  Tool Usage")
	fmt.Printf("  Total Tool Calls:      %d\n", metrics.TotalToolCalls)
	fmt.Printf("  Avg Calls/Session:     %.1f\n", metrics.AvgCallsPerSession)

	if len(metrics.TopTools) > 0 {
		fmt.Println("\nðŸ” Most Called Tools")
		for i, tool := range metrics.TopTools {
			if i >= 5 {
				break
			}
			fmt.Printf("  %d. %-40s %4d calls (%.1f%%)\n",
				i+1,
				truncateString(tool.ToolName, 40),
				tool.Count,
				tool.Percent,
			)
		}
	}

	if len(metrics.RecentSessions) > 0 {
		fmt.Println("\nðŸ“… Recent Sessions")
		for i, sess := range metrics.RecentSessions {
			if i >= 3 {
				break
			}

			timeAgo := formatTimeAgo(sess.CreatedAt)
			sessionID := sess.ID
			if len(sessionID) > 30 {
				sessionID = sessionID[:27] + "..."
			}

			fmt.Printf("  â€¢ %s - %s (%d tools, %s ago)\n",
				sessionID,
				formatDuration(sess.Duration),
				sess.ToolCallCount,
				timeAgo,
			)
		}
	}

	fmt.Println()
	return nil
}

func runFakerSessionReplay(cmd *cobra.Command, args []string) error {
	sessionID := args[0]

	db, err := getDB()
	if err != nil {
		return fmt.Errorf("failed to get database: %w", err)
	}
	defer db.Close()

	svc := faker.NewSessionService(db)

	// Get replayable session
	jsonData, err := svc.ExportReplayableSessionJSON(context.Background(), sessionID)
	if err != nil {
		return fmt.Errorf("failed to export session: %w", err)
	}

	// Output JSON to stdout (can be redirected to file)
	fmt.Println(string(jsonData))
	return nil
}

// Helper functions

func formatDuration(d time.Duration) string {
	if d < time.Minute {
		return fmt.Sprintf("%ds", int(d.Seconds()))
	}
	if d < time.Hour {
		return fmt.Sprintf("%dm %ds", int(d.Minutes()), int(d.Seconds())%60)
	}
	return fmt.Sprintf("%dh %dm", int(d.Hours()), int(d.Minutes())%60)
}

func formatTimeAgo(t time.Time) string {
	duration := time.Since(t)

	if duration < time.Minute {
		return "just now"
	}
	if duration < time.Hour {
		mins := int(duration.Minutes())
		if mins == 1 {
			return "1 minute"
		}
		return fmt.Sprintf("%d minutes", mins)
	}
	if duration < 24*time.Hour {
		hours := int(duration.Hours())
		if hours == 1 {
			return "1 hour"
		}
		return fmt.Sprintf("%d hours", hours)
	}

	days := int(duration.Hours() / 24)
	if days == 1 {
		return "1 day"
	}
	return fmt.Sprintf("%d days", days)
}

func truncateString(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}
